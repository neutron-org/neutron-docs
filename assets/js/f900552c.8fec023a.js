"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[33581],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),h=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=h(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=h(n),c=i,p=d["".concat(s,".").concat(c)]||d[c]||m[c]||o;return n?a.createElement(p,r(r({ref:t},u),{},{components:n})):a.createElement(p,r({ref:t},u))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var h=2;h<o;h++)r[h]=n[h];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},97294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var a=n(87462),i=(n(67294),n(3905));const o={},r="Overview",l={unversionedId:"neutron/modules/ibc-rate-limits/overview",id:"neutron/modules/ibc-rate-limits/overview",title:"Overview",description:"Motivation",source:"@site/docs/neutron/modules/ibc-rate-limits/overview.md",sourceDirName:"neutron/modules/ibc-rate-limits",slug:"/neutron/modules/ibc-rate-limits/overview",permalink:"/neutron/modules/ibc-rate-limits/overview",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Metrics",permalink:"/neutron/modules/cron/metrics"},next:{title:"Overview",permalink:"/neutron/modules/3rdparty/skip/block-sdk/overview"}},s={},h=[{value:"Motivation",id:"motivation",level:2},{value:"Rate limit types",id:"rate-limit-types",level:2},{value:"Instantiating rate limits",id:"instantiating-rate-limits",level:2},{value:"Parameterizing the rate limit",id:"parameterizing-the-rate-limit",level:2},{value:"Handling rate limit boundaries",id:"handling-rate-limit-boundaries",level:3},{value:"Inflow parameterization",id:"inflow-parameterization",level:3},{value:"Outflow parameterization",id:"outflow-parameterization",level:3},{value:"Cosmwasm Contract Concepts",id:"cosmwasm-contract-concepts",level:3},{value:"Messages",id:"messages",level:4},{value:"Query",id:"query",level:5},{value:"Exec",id:"exec",level:5},{value:"Sudo",id:"sudo",level:5},{value:"Necessary information",id:"necessary-information",level:3},{value:"Notes on Channel",id:"notes-on-channel",level:4},{value:"Notes on Denom",id:"notes-on-denom",level:4},{value:"Sends",id:"sends",level:5},{value:"Receives",id:"receives",level:5},{value:"Notes on Channel Value",id:"notes-on-channel-value",level:4},{value:"Caching",id:"caching",level:5},{value:"Integration",id:"integration",level:3}],u={toc:h},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"overview"},"Overview"),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"The motivation of IBC-rate-limit comes from the empirical observations of blockchain bridge hacks that a rate limit would have massively reduced the stolen amount of assets in:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rekt.news/polynetwork-rekt/"},"Polynetwork Bridge Hack ($611 million)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rekt.news/bnb-bridge-rekt/"},"BNB Bridge Hack ($586 million)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rekt.news/wormhole-rekt/"},"Wormhole Bridge Hack ($326 million)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rekt.news/nomad-rekt/"},"Nomad Bridge Hack ($190 million)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rekt.news/harmony-rekt/"},"Harmony Bridge Hack ($100 million)")," - (Would require rate limit + monitoring)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://forum.cosmos.network/t/ibc-security-advisory-dragonberry/7702"},"Dragonberry IBC bug")," (can't yet disclose amount at risk, but was saved due to being found first by altruistic Osmosis core developers)")),(0,i.kt)("p",null,"In the presence of a software bug on Neutron, IBC itself, or on a counterparty chain, we would like to prevent the bridge from being fully depegged.\nThis stems from the idea that a 30% asset depeg is ~infinitely better than a 100% depeg.\nIts ",(0,i.kt)("em",{parentName:"p"},"crazy")," that today these complex bridged assets can instantly go to 0 in event of bug.\nThe goal of a rate limit is to raise an alert that something has potentially gone wrong, allowing validators and developers to have time to analyze, react, and protect larger portions of user funds."),(0,i.kt)("p",null,"The thesis of this is that, it is worthwhile to sacrifice liveness in the case of legitimate demand to send extreme amounts of funds, to prevent the terrible long-tail full fund risks.\nRate limits aren't the end-all of safety controls, they're merely the simplest automated one. More should be explored and added onto IBC!"),(0,i.kt)("h2",{id:"rate-limit-types"},"Rate limit types"),(0,i.kt)("p",null,"We express rate limits in time-based periods.\nThis means, we set rate limits for (say) 6-hour, daily, and weekly intervals.\nThe rate limit for a given time period stores the relevant amount of assets at the start of the rate limit.\nRate limits are then defined on percentage terms of the asset.\nThe time windows for rate limits are currently ",(0,i.kt)("em",{parentName:"p"},"not")," rolling, they have discrete start/end times."),(0,i.kt)("p",null,"We allow setting separate rate limits for the inflow and outflow of assets.\nWe do all of our rate limits based on the ",(0,i.kt)("em",{parentName:"p"},"net flow")," of assets on a channel pair. This prevents DOS issues, of someone repeatedly sending assets back and forth, to trigger rate limits and break liveness."),(0,i.kt)("p",null,"We currently envision creating two kinds of rate limits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Per denomination rate limits",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'allows safety statements like "Only 30% of Stars on Neutron can flow out in one day" or "The amount of Atom on Neutron can at most double per day".'))),(0,i.kt)("li",{parentName:"ul"},"Per channel rate limits",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'Limit the total inflow and outflow on a given IBC channel, based on "USDC" equivalent, using Neutron as the price oracle.')))),(0,i.kt)("p",null,"We currently only implement per denomination rate limits for non-native assets. We do not yet implement channel based rate limits."),(0,i.kt)("p",null,'Currently these rate limits automatically "expire" at the end of the quota duration.'),(0,i.kt)("h2",{id:"instantiating-rate-limits"},"Instantiating rate limits"),(0,i.kt)("p",null,"Today all rate limit quotas must be set manually by governance.\nIn the future, we should design towards some conservative rate limit to add as a safety-backstop automatically for channels.\nIdeas for how this could look:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"One month after a channel has been created, automatically add in some USDC-based rate limit"),(0,i.kt)("li",{parentName:"ul"},"One month after governance incentivizes an asset, add on a per-denomination rate limit.")),(0,i.kt)("p",null,"Definitely needs far more ideation and iteration!"),(0,i.kt)("h2",{id:"parameterizing-the-rate-limit"},"Parameterizing the rate limit"),(0,i.kt)("p",null,"One element is we don't want any rate limit timespan that's too short, e.g. not enough time for humans to react to. So we wouldn't want a 1 hour rate limit, unless we think that if its hit, it could be assessed within an hour."),(0,i.kt)("h3",{id:"handling-rate-limit-boundaries"},"Handling rate limit boundaries"),(0,i.kt)("p",null,'We want to be safe against the case where say we have a daily rate limit ending at a given time, and an adversary attempts to attack near the boundary window.\nWe would not like them to be able to "double extract funds" by timing their extraction near a window boundary.'),(0,i.kt)("p",null,"Admittedly, not a lot of thought has been put into how to deal with this well.\nRight now we envision simply handling this by saying if you want a quota of duration D, instead include two quotas of duration D, but offset by ",(0,i.kt)("inlineCode",{parentName:"p"},"D/2")," from each other."),(0,i.kt)("p",null,"Ideally we can change windows to be more 'rolling' in the future, to avoid this overhead and more cleanly handle the problem. (Perhaps rolling ~1 hour at a time)"),(0,i.kt)("h3",{id:"inflow-parameterization"},"Inflow parameterization"),(0,i.kt)("p",null,'The "Inflow" side of a rate limit is essentially protection against unforeseen bug on a counterparty chain.\nThis can be quite conservative (e.g. bridged amount doubling in one week).'),(0,i.kt)("p",null,"It does get more complex when the counterparty chain is itself a DEX, but this is still much more protection than nothing."),(0,i.kt)("h3",{id:"outflow-parameterization"},"Outflow parameterization"),(0,i.kt)("p",null,'The "Outflow" side of a rate limit is protection against a bug on Neutron OR IBC.\nThis has potential for much more user-frustrating issues, if set too low.\nE.g. if there\'s some event that causes many people to suddenly withdraw many STARS or many USDC.'),(0,i.kt)("p",null,"So this parameterization has to contend with being a tradeoff of withdrawal liveness in high volatility periods vs being a crucial safety rail, in event of on-Neutron bug."),(0,i.kt)("h3",{id:"cosmwasm-contract-concepts"},"Cosmwasm Contract Concepts"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: the contract implementation can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/rate-limiter-contract"},"here"))),(0,i.kt)("p",null,"Something to keep in mind with all of the code, is that we have to reason separately about every item in the following matrix:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Native Token"),(0,i.kt)("th",{parentName:"tr",align:null},"Non-Native Token"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Send Native Token"),(0,i.kt)("td",{parentName:"tr",align:null},"Send Non-Native Token")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Receive Native Token"),(0,i.kt)("td",{parentName:"tr",align:null},"Receive Non-Native Token")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Timeout Native Send"),(0,i.kt)("td",{parentName:"tr",align:null},"Timeout Non-native Send")))),(0,i.kt)("p",null,"(Error ACK can reuse the same code as timeout)"),(0,i.kt)("p",null,"The tracking contract uses the following concepts"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"RateLimit")," - tracks the value flow transferred and the quota for a path."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Path")," - is a (denom, channel) pair."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Flow")," - tracks the value that has moved through a path during the current time window."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Quota")," - is the percentage of the denom's total value that can be transferred through the path in a given period of time (duration)")),(0,i.kt)("h4",{id:"messages"},"Messages"),(0,i.kt)("p",null,"The contract specifies the following messages:"),(0,i.kt)("h5",{id:"query"},"Query"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"GetQuotas - Returns the quotas for a path")),(0,i.kt)("h5",{id:"exec"},"Exec"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"AddPath - Adds a list of quotas for a path"),(0,i.kt)("li",{parentName:"ul"},"RemovePath - Removes a path"),(0,i.kt)("li",{parentName:"ul"},"ResetPathQuota - If a rate limit has been reached, the contract's governance address can reset the quota so that transfers are allowed again")),(0,i.kt)("h5",{id:"sudo"},"Sudo"),(0,i.kt)("p",null,"Sudo messages can only be executed by the chain."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SendPacket - Increments the amount used out of the send quota and checks that the send is allowed. If it isn't, it will return a RateLimitExceeded error"),(0,i.kt)("li",{parentName:"ul"},"RecvPacket - Increments the amount used out of the receive quota and checks that the receive is allowed. If it isn't, it will return a RateLimitExceeded error"),(0,i.kt)("li",{parentName:"ul"},"UndoSend - If a send has failed, the undo message is used to remove its cost from the send quota")),(0,i.kt)("p",null,"All of these messages receive the packet from the chain and extract the necessary information to process the packet and determine if it should be the rate limited."),(0,i.kt)("h3",{id:"necessary-information"},"Necessary information"),(0,i.kt)("p",null,"To determine if a packet should be rate limited, we need:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Channel: The channel on the Neutron side: ",(0,i.kt)("inlineCode",{parentName:"li"},"packet.SourceChannel")," for sends, and ",(0,i.kt)("inlineCode",{parentName:"li"},"packet.DestinationChannel")," for receives."),(0,i.kt)("li",{parentName:"ul"},"Denom: The denom of the token being transferred as known on the Neutron side (more on that below)"),(0,i.kt)("li",{parentName:"ul"},"Channel Value: The total value of the channel denominated in ",(0,i.kt)("inlineCode",{parentName:"li"},"Denom")," (i.e.: channel-17 is worth 10k osmo)."),(0,i.kt)("li",{parentName:"ul"},"Funds: the amount being transferred")),(0,i.kt)("h4",{id:"notes-on-channel"},"Notes on Channel"),(0,i.kt)("p",null,'The contract also supports quotas on a custom channel called "any" that is checked on every transfer. If either the\ntransfer channel or the "any" channel have a quota that has been filled, the transaction will be rate limited.'),(0,i.kt)("h4",{id:"notes-on-denom"},"Notes on Denom"),(0,i.kt)("p",null,'We always use the the denom as represented on Neutron. For native assets that is the local denom, and for non-native\nassets it\'s the "ibc" prefix and the sha256 hash of the denom trace (',(0,i.kt)("inlineCode",{parentName:"p"},"ibc/..."),")."),(0,i.kt)("h5",{id:"sends"},"Sends"),(0,i.kt)("p",null,"For native denoms, we can just use the denom in the packet. If the denom is invalid, it will fail somewhere else along the chain. Example result: ",(0,i.kt)("inlineCode",{parentName:"p"},"uosmo")),(0,i.kt)("p",null,"For non-native denoms, the contract needs to hash the denom trace and append it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ibc/")," prefix. The\ncontract always receives the parsed denom (i.e.: ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer/channel-32/uatom")," instead of\n",(0,i.kt)("inlineCode",{parentName:"p"},"ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2"),"). This is because of the order in which\nthe middleware is called. When sending a non-native denom, the packet contains ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer/source-channel/denom")," as it\nis built on the ",(0,i.kt)("inlineCode",{parentName:"p"},"relay.SendTransfer()")," in the transfer module and then passed to the middleware. Example result: ",(0,i.kt)("inlineCode",{parentName:"p"},"ibc/<hash>")),(0,i.kt)("h5",{id:"receives"},"Receives"),(0,i.kt)("p",null,'This behaves slightly different if the asset is an Neutron asset that was sent to the counterparty and is being\nreturned to the chain, or if the asset is being received by the chain and originates on the counterparty. In ibc this\nis called being a "source" or a "sink" respectively.'),(0,i.kt)("p",null,"If the chain is a sink for the denom, we build the local denom by prefixing the port and the channel\n(",(0,i.kt)("inlineCode",{parentName:"p"},"transfer/local-channel"),") and hashing that denom. Example result: ",(0,i.kt)("inlineCode",{parentName:"p"},"ibc/<hash>")),(0,i.kt)("p",null,"If the chain is the source for the denom, there are two possibilities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The token is a native token, in which case we just remove the prefix added by the counterparty. Example result: ",(0,i.kt)("inlineCode",{parentName:"li"},"uosmo")),(0,i.kt)("li",{parentName:"ul"},"The token is a non-native token, in which case we remove the extra prefix and hash it. Example result ",(0,i.kt)("inlineCode",{parentName:"li"},"ibc/<hash>"))),(0,i.kt)("h4",{id:"notes-on-channel-value"},"Notes on Channel Value"),(0,i.kt)("p",null,"We have iterated on different strategies for calculating the channel value. Our preferred strategy is the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For non-native tokens (",(0,i.kt)("inlineCode",{parentName:"li"},"ibc/..."),"), the channel value should be the supply of those tokens in Neutron"),(0,i.kt)("li",{parentName:"ul"},"For native tokens, the channel value should be the total amount of tokens in escrow across all ibc channels")),(0,i.kt)("p",null,'The later ensures the limits are lower and represent the amount of native tokens that exist outside Neutron. This is\nbeneficial as we assume the majority of native tokens exist on the native chain and the amount "normal" ibc transfers is\nproportional to the tokens that have left the chain.'),(0,i.kt)("p",null,"This strategy cannot be implemented at the moment because IBC does not track the amount of tokens in escrow across\nall channels (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/issues/2664"},"github issue"),"). Instead, we use the current supply on\nNeutron for all denoms (i.e.: treat native and non-native tokens the same way). Once that ticket is fixed, we will\nupdate this strategy."),(0,i.kt)("h5",{id:"caching"},"Caching"),(0,i.kt)("p",null,"The channel value varies constantly. To have better predictability, and avoid issues of the value growing if there is\na potential infinite mint bug, we cache the channel value at the beginning of the period for every quota."),(0,i.kt)("p",null,"This means that if we have a daily quota of 1% of the osmo supply, and the channel value is 1M osmo at the beginning of\nthe quota, no more than 100k osmo can transferred during that day. If 10M osmo were to be minted or IBC'd in during that\nperiod, the quota will not increase until the period expired. Then it will be 1% of the new channel value (~11M)"),(0,i.kt)("h3",{id:"integration"},"Integration"),(0,i.kt)("p",null,"The rate limit middleware wraps the ",(0,i.kt)("inlineCode",{parentName:"p"},"transferIBCModule")," and is added as the entry route for IBC transfers."),(0,i.kt)("p",null,"The module is also provided to the underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"transferIBCModule")," as its ",(0,i.kt)("inlineCode",{parentName:"p"},"ICS4Wrapper"),"; previously, this would have\npointed to a channel, which also implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"ICS4Wrapper")," interface."),(0,i.kt)("p",null,"This integration can be seen in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron/blob/cfa54003cf1f8e9e7dd0d713c80605641d14f610/app/app.go#L1656"},"neutron/app/app.go")))}m.isMDXComponent=!0}}]);