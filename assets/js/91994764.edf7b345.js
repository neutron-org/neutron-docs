"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[7848],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(n),m=s,h=d["".concat(u,".").concat(m)]||d[m]||p[m]||a;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,o=new Array(a);o[0]=m;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[d]="string"==typeof e?e:s,o[1]=i;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96238:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(87462),s=(n(67294),n(3905));const a={},o="CosmWasm + ICQ",i={unversionedId:"tutorials/cosmwasm_icq",id:"version-2.0/tutorials/cosmwasm_icq",title:"CosmWasm + ICQ",description:"This section contains a tutorial for writing smart contracts that utilize Interchain Queries Module.",source:"@site/versioned_docs/version-2.0/tutorials/cosmwasm_icq.md",sourceDirName:"tutorials",slug:"/tutorials/cosmwasm_icq",permalink:"/2.0/tutorials/cosmwasm_icq",draft:!1,tags:[],version:"2.0",frontMatter:{},sidebar:"docs",previous:{title:"CosmWasm + ICA",permalink:"/2.0/tutorials/cosmwasm_ica"},next:{title:"Integration tests for chain",permalink:"/2.0/tutorials/integration-tests/chain"}},u={},l=[{value:"Overview",id:"overview",level:2},{value:"The complete example",id:"the-complete-example",level:2},{value:"1. Install dependencies and import the libraries",id:"1-install-dependencies-and-import-the-libraries",level:2},{value:"2. Register an Interchain Query",id:"2-register-an-interchain-query",level:2},{value:"3. Get results from the registered Interchain Queries",id:"3-get-results-from-the-registered-interchain-queries",level:2},{value:"Get results from KV-queries",id:"get-results-from-kv-queries",level:3},{value:"Get results from TX-queries",id:"get-results-from-tx-queries",level:3},{value:"4. Manage registered Interchain Queries",id:"4-manage-registered-interchain-queries",level:2},{value:"Learning to make your own queries that are not in Neutron SDK",id:"learning-to-make-your-own-queries-that-are-not-in-neutron-sdk",level:2}],c={toc:l},d="wrapper";function p(e){let{components:t,...n}=e;return(0,s.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"cosmwasm--icq"},"CosmWasm + ICQ"),(0,s.kt)("p",null,"This section contains a tutorial for writing smart contracts that utilize Interchain Queries Module."),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("p",null,"We are going to learn how to:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Install dependencies and import the libraries."),(0,s.kt)("li",{parentName:"ol"},"Register different Interchain Queries."),(0,s.kt)("li",{parentName:"ol"},"Get results from the registered Interchain Queries."),(0,s.kt)("li",{parentName:"ol"},"Manage the registered Interchain Queries.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," this section assumes that you have basic knowledge of CosmWasm and have some experience in writing smart\ncontracts. You can check out CosmWasm ",(0,s.kt)("a",{parentName:"p",href:"https://docs.cosmwasm.com/docs"},"docs"),"\nand ",(0,s.kt)("a",{parentName:"p",href:"https://medium.com/cosmwasm/writing-a-cosmwasm-contract-8fb946c3a516"},"blog posts")," for entry-level tutorials.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," before running any query creation transaction you need to top up your contract address. See ",(0,s.kt)("a",{parentName:"p",href:"/2.0/neutron/modules/interchain-queries/overview"},"Interchain Queries Overview"),', "Query creation deposit" section.')),(0,s.kt)("h2",{id:"the-complete-example"},"The complete example"),(0,s.kt)("p",null,"In the snippets below some details might be omitted. Please check out the complete smart contract\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/tree/main/contracts/neutron_interchain_queries"},"example")," for a complete\nimplementation."),(0,s.kt)("h2",{id:"1-install-dependencies-and-import-the-libraries"},"1. Install dependencies and import the libraries"),(0,s.kt)("p",null,"In order to start using the Neutron ICQ module, you need to install some dependencies. Add the following\nlibraries to your dependencies section:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\ncosmwasm-std = "1.2.5"\n\n# Other standard dependencies...\n\n# This is a library that simplifies working with ICQ,\n# contains bindings for the Neutron ICQ module (messages, responses, etc.), some default Interchain Queries and provides\n# various helper functions.\nneutron-sdk = "0.5.0"\n')),(0,s.kt)("p",null,"Now you can import the libraries:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"use neutron_sdk::{\n    bindings::{\n        msg::NeutronMsg,\n        query::{NeutronQuery, QueryRegisteredQueryResponse},\n        types::{Height, KVKey},\n    },\n    interchain_queries::{\n        new_register_balance_query_msg,\n        new_register_transfers_query_msg,\n        queries::{\n            get_registered_query, query_balance,\n        },\n        register_queries::new_register_interchain_query_msg,\n        types::{\n            QueryType, TransactionFilterItem, TransactionFilterOp, TransactionFilterValue,\n            COSMOS_SDK_TRANSFER_MSG_URL, RECIPIENT_FIELD,\n        },\n    },\n    sudo::msg::SudoMsg,\n    NeutronError, NeutronResult,\n};\n")),(0,s.kt)("h2",{id:"2-register-an-interchain-query"},"2. Register an Interchain Query"),(0,s.kt)("p",null,"Neutron allows a smart contract to register multiple interchain queries:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n    RegisterBalanceQuery {\n        connection_id: String,\n        update_period: u64,\n        addr: String,\n        denom: String,\n    },\n    RegisterTransfersQuery {\n        connection_id: String,\n        update_period: u64,\n        recipient: String,\n        min_height: Option<u64>,\n    }\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    deps: DepsMut<NeutronQuery>,\n    env: Env,\n    _: MessageInfo,\n    msg: ExecuteMsg,\n) -> NeutronResult<Response<NeutronMsg>> {\n    match msg {\n        ExecuteMsg::RegisterBalanceQuery {\n            connection_id,\n            addr,\n            denom,\n            update_period,\n        } => register_balance_query(\n            deps,\n            env,\n            connection_id,\n            addr,\n            denom,\n            update_period,\n        ),\n        ExecuteMsg::RegisterTransfersQuery {\n            connection_id,\n            recipient,\n            update_period,\n            min_height,\n        } => register_transfers_query(\n            deps,\n            env,\n            connection_id,\n            recipient,\n            update_period,\n            min_height,\n        ),\n    }\n}\n\npub fn register_balance_query(\n    deps: DepsMut<NeutronQuery>,\n    env: Env,\n    connection_id: String,\n    addr: String,\n    denom: String,\n    update_period: u64,\n) -> NeutronResult<Response<NeutronMsg>> {\n    let msg = new_register_balance_query_msg(connection_id, addr, denom, update_period)?;\n    // wrap into submessage to save {query_id, query_type} on reply that\'ll later be used to handle sudo kv callback\n    let submsg = SubMsg::reply_on_success(msg, BALANCES_REPLY_ID);\n\n    Ok(Response::default().add_submessage(submsg))\n}\n\npub fn register_transfers_query(\n    deps: DepsMut<NeutronQuery>,\n    env: Env,\n    connection_id: String,\n    recipient: String,\n    update_period: u64,\n    min_height: Option<u64>,\n) -> NeutronResult<Response<NeutronMsg>> {\n    let msg = new_register_transfers_query_msg(\n        deps,\n        env,\n        connection_id,\n        recipient,\n        update_period,\n        min_height,\n    )?;\n\n    Ok(Response::new().add_message(msg))\n}\n\n#[entry_point]\npub fn reply(deps: DepsMut, _: Env, msg: Reply) -> StdResult<Response> {\n    deps.api\n        .debug(format!("WASMDEBUG: reply msg: {:?}", msg).as_str());\n    match msg.id {\n        BALANCES_REPLY_ID => write_balance_query_id_to_reply_id(deps, msg),\n        _ => Err(StdError::generic_err(format!(\n            "unsupported reply message id {}",\n            msg.id\n        ))),\n    }\n}\n\n\npub const KV_QUERY_ID_TO_CALLBACKS: Map<u64, QueryKind> = Map::new("kv_query_id_to_callbacks");\n\n// contains query kinds that we expect to handle in `sudo_kv_query_result`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub enum QueryKind {\n    // Balance query\n    Balance,\n    // You can add your handlers to understand what query to deserialize by query_id in sudo callback\n}\n\n// save query_id to query_type information in reply, so that we can understand the kind of query we\'re getting in sudo kv call\nfn write_balance_query_id_to_reply_id(deps: DepsMut, reply: Reply) -> StdResult<Response> {\n    let resp: MsgRegisterInterchainQueryResponse = serde_json_wasm::from_slice(\n        reply\n            .result\n            .into_result()\n            .map_err(StdError::generic_err)?\n            .data\n            .ok_or_else(|| StdError::generic_err("no result"))?\n            .as_slice(),\n    )\n    .map_err(|e| StdError::generic_err(format!("failed to parse response: {:?}", e)))?;\n\n    // then in success reply handler we do this\n    KV_QUERY_ID_TO_CALLBACKS.save(deps.storage, resp.id, &QueryKind::Balance)?;\n\n    Ok(Response::default())\n}\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," the ICQ module's ",(0,s.kt)("inlineCode",{parentName:"p"},"RegisterInterchainQueryMsg")," message ",(0,s.kt)("a",{parentName:"p",href:"/neutron/modules/interchain-queries/messages#register-interchain-query"},"returns"),"\nan identifier of newly registered Interchain Query in response. So in a real world scenario you should implement a ",(0,s.kt)("inlineCode",{parentName:"p"},"reply")," handler in your contract\nto catch the identifier after the registration, so you'll be able to work with the registered query later.")),(0,s.kt)("p",null,"In the snippet above, we create the ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," enum that contains two ",(0,s.kt)("inlineCode",{parentName:"p"},"Register")," messages for two different queries:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"RegisterBalanceQuery")," - a simple KV-query to query a balance of an account on remote chain;"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"RegisterTransfersQuery")," - a TX-query to query transfers transactions to a some recipient on remote chain.")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," in a real-world scenario you wouldn't want just anyone to be able to make your contract register interchain\nquery, so it might make sense to add ownership checks")),(0,s.kt)("p",null,"And implement simple handlers ",(0,s.kt)("inlineCode",{parentName:"p"},"register_balance_query")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"register_transfers_query")," for these messages. Each handler\nuses built-in helpers from Neutron-SDK to create necessary register messages: ",(0,s.kt)("inlineCode",{parentName:"p"},"new_register_balance_query_msg")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"new_register_transfers_query_msg"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"new_register_balance_query_msg")," - is a KV-query, therefore it creates an Interchain Query with necessary KV-keys to read\nfrom remote chain and build a full ",(0,s.kt)("inlineCode",{parentName:"li"},"Balance")," response from KV-values (you can see a full implementation of the helper in the ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/register_queries.rs#L52"},"SDK source code"),"):")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn new_register_balance_query_msg(...) -> NeutronResult<NeutronMsg> {\n    // convert bech32 encoded address to a bytes representation\n    let converted_addr_bytes = decode_and_convert(addr.as_str())?;\n\n    // creates a balance KV-key with necessary prefixes we want to read from the storage on remote chain\n    let balance_key = create_account_denom_balance_key(converted_addr_bytes, denom)?;\n\n    let kv_key = KVKey {\n        path: BANK_STORE_KEY.to_string(),\n        key: Binary(balance_key),\n    };\n\n    ...\n}\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"new_register_transfers_query_msg")," - is a TX-query, therefore it creates an Interchain Query with necessary TX-filter\nto receive only required transactions from remote chain (you can see a full implementation of the helper in the ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/register_queries.rs#L220"},"SDK source code"),"):")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn new_register_transfers_query_msg(...) -> NeutronResult<NeutronMsg> {\n    // in this case the function creates filter to receive only transactions with transfer msg in it with a particular recipient\n    let mut query_data: Vec<TransactionFilterItem> = vec![TransactionFilterItem {\n        field: RECIPIENT_FIELD.to_string(),\n        op: TransactionFilterOp::Eq,\n        value: TransactionFilterValue::String(recipient),\n    }];\n\n    ...\n}\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," Neutron SDK is shipped with a lot of helpers to register different Interchain Queries (you can find a full list ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.6.0/packages/neutron-sdk/src/interchain_queries/v045/register_queries.rs"},"here"),").\nBut if you don't find some particular register query helper in the SDK, you can always implement your own using implementations from SDK as a reference.\nWe encourage you to open pull requests with your query implementations to make Neutron SDK better and better!")),(0,s.kt)("h2",{id:"3-get-results-from-the-registered-interchain-queries"},"3. Get results from the registered Interchain Queries"),(0,s.kt)("h3",{id:"get-results-from-kv-queries"},"Get results from KV-queries"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum QueryMsg {\n    GetRegisteredQuery { query_id: u64 },\n    Balance { query_id: u64 },\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps<NeutronQuery>, env: Env, msg: QueryMsg) -> NeutronResult<Binary> {\n    match msg {\n        QueryMsg::GetRegisteredQuery { query_id } => {\n            Ok(to_binary(&get_registered_query(deps, query_id)?)?)\n        },\n        QueryMsg::Balance { query_id } => Ok(to_binary(&query_balance(deps, env, query_id)?)?),\n        QueryMsg::GetTransfersNumber {} => query_transfers_number(deps),\n    }\n}\n')),(0,s.kt)("p",null,"In the snippet above we create the ",(0,s.kt)("inlineCode",{parentName:"p"},"QueryMsg")," enum that contains three msgs: ",(0,s.kt)("inlineCode",{parentName:"p"},"GetRegisteredQuery"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Balance"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"GetTransfersNumber"),", and a ",(0,s.kt)("inlineCode",{parentName:"p"},"query"),"\nentrypoint which handles the defined query msgs. "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the handler of ",(0,s.kt)("inlineCode",{parentName:"li"},"GetRegisteredQuery")," uses ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/queries.rs#L67"},"built-in SDK helper")," ",(0,s.kt)("inlineCode",{parentName:"li"},"get_registered_query")," to get all the information about\nany registered query by its id;"),(0,s.kt)("li",{parentName:"ul"},"the handler of ",(0,s.kt)("inlineCode",{parentName:"li"},"Balance")," is much more interesting. It uses ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/queries.rs#L103"},"built-in SDK helper")," ",(0,s.kt)("inlineCode",{parentName:"li"},"query_balance")," to query interchain balance:"),(0,s.kt)("li",{parentName:"ul"},"the handler of ",(0,s.kt)("inlineCode",{parentName:"li"},"GetTransfersNumber")," will be below in the ",(0,s.kt)("a",{parentName:"li",href:"#get-results-from-tx-queries"},"section about tx queries handling"),".")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn query_balance(\n    deps: Deps<NeutronQuery>,\n    _env: Env,\n    registered_query_id: u64,\n) -> NeutronResult<BalanceResponse> {\n    // get info about the query\n    let registered_query = get_registered_query(deps, registered_query_id)?;\n    // check that query type is KV\n    check_query_type(registered_query.registered_query.query_type, QueryType::KV)?;\n    // reconstruct a nice Balances structure from raw KV-storage values\n    let balances: Balances = query_kv_result(deps, registered_query_id)?;\n\n    Ok(BalanceResponse {\n        // last_submitted_height tells us when the query result was updated last time (block height)\n        last_submitted_local_height: registered_query\n            .registered_query\n            .last_submitted_result_local_height,\n        balances,\n    })\n}\n")),(0,s.kt)("p",null,"The most import function here is ",(0,s.kt)("inlineCode",{parentName:"p"},"query_kv_result"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"/// Reads submitted raw KV values for Interchain Query with **query_id** from the storage and reconstructs the result\npub fn query_kv_result<T: KVReconstruct>(\n    deps: Deps<NeutronQuery>,\n    query_id: u64,\n) -> NeutronResult<T> {\n    let registered_query_result = get_interchain_query_result(deps, query_id)?;\n\n    KVReconstruct::reconstruct(&registered_query_result.result.kv_results)\n}\n")),(0,s.kt)("p",null,"It is built-in into SDK, and it uses ",(0,s.kt)("inlineCode",{parentName:"p"},"KVReconstruct")," ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/types.rs#L175"},"trait"),"\nto reconstruct KV-storage values into a nice structure.\nMeaning any structure that implements ",(0,s.kt)("inlineCode",{parentName:"p"},"KVReconstruct")," trait can be used with ",(0,s.kt)("inlineCode",{parentName:"p"},"query_kv_result")," helper.\nIn our case we want to reconstruct ",(0,s.kt)("inlineCode",{parentName:"p"},"Balances")," from KV-values. ",(0,s.kt)("inlineCode",{parentName:"p"},"Balances")," is a build-in SDK structure and it already ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/v0.5.0/packages/neutron-sdk/src/interchain_queries/types.rs#L202"},"implements"),"\n",(0,s.kt)("inlineCode",{parentName:"p"},"KVReconstruct")," trait, so no additional functionality is required from developers, you can just import and use it as it is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n/// A structure that can be reconstructed from **StorageValues**'s for the **Balance Interchain Query**.\n/// Contains coins that are held by some account on remote chain.\npub struct Balances {\n    pub coins: Vec<Coin>,\n}\n\nimpl KVReconstruct for Balances {\n    fn reconstruct(storage_values: &[StorageValue]) -> NeutronResult<Balances> {\n        let mut coins: Vec<Coin> = Vec::with_capacity(storage_values.len());\n\n        for kv in storage_values {\n            let balance: CosmosCoin = CosmosCoin::decode(kv.value.as_slice())?;\n            let amount = Uint128::from_str(balance.amount.as_str())?;\n            coins.push(Coin::new(amount.u128(), balance.denom));\n        }\n\n        Ok(Balances { coins })\n    }\n}\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Note:")," Neutron SDK is shipped with a lot of query structures to reconstruct different Interchain Queries (you can find a full list ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/main/packages/neutron-sdk/src/interchain_queries/types.rs"},"here")," by looking for structs implementing the KVReconstruct trait).\nBut if you don't find some particular structure in the SDK, you can always implement your own using implementations from SDK as a reference.\nAll you need to do is just implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"KVReconstruct")," trait for your structure, and after that you can easily use this with ",(0,s.kt)("inlineCode",{parentName:"p"},"query_kv_result")," helper like this:\n",(0,s.kt)("inlineCode",{parentName:"p"},"let response: YourStructure = query_kv_result(deps, query_id)?"))),(0,s.kt)("p",null,"Sometimes you might want to get KV Interchain Queries result immediately after it was published by the ",(0,s.kt)("a",{parentName:"p",href:"/relaying/icq-relayer"},"ICQ relayer"),".\nThat's why we've implemented ",(0,s.kt)("strong",{parentName:"p"},"KV Queries Callbacks"),", which allows you to get a callback in your contract with the query result when the relayer submits it.\nKV callbacks are implemented via ",(0,s.kt)("strong",{parentName:"p"},"Sudo")," calls in your smart-contract:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#[entry_point]\npub fn sudo(deps: DepsMut<NeutronQuery>, env: Env, msg: SudoMsg) -> NeutronResult<Response> {\n    match msg {\n        SudoMsg::KVQueryResult { query_id } => sudo_kv_query_result(deps, env, query_id),\n        _ => Ok(Response::default()),\n    }\n}\n\n/// sudo_kv_query_result is the contract\'s callback for KV query results. Note that only the query\n/// id is provided, so you need to read the query result from the state.\npub fn sudo_kv_query_result(\n    deps: DepsMut<NeutronQuery>,\n    env: Env,\n    query_id: u64,\n) -> NeutronResult<Response> {\n    deps.api.debug(\n        format!(\n            "WASMDEBUG: sudo_kv_query_result received; query_id: {:?}",\n            query_id,\n        )\n            .as_str(),\n    );\n\n    // store last KV callback update time\n    KV_CALLBACK_STATS.save(deps.storage, query_id, &env.block.height)?;\n\n    let query_kind = KV_QUERY_ID_TO_CALLBACKS.may_load(deps.storage, query_id)?;\n    match query_kind {\n        Some(QueryKind::Balance) => {\n            let balances: Balances = query_kv_result(deps.as_ref(), query_id)?;\n            let balances_str = balances\n                .coins\n                .iter()\n                .map(|c| c.amount.to_string() + c.denom.as_str())\n                .collect::<Vec<String>>()\n                .join(", ");\n            deps.api\n                .debug(format!("WASMDEBUG: sudo callback; balances: {:?}", balances_str).as_str());\n        }\n        None => {\n            deps.api.debug(\n                format!(\n                    "WASMDEBUG: sudo callback without query kind assigned; query_id: {:?}",\n                    query_id\n                )\n                .as_str(),\n            );\n        }\n    }\n    Ok(Response::default())\n}\n')),(0,s.kt)("p",null,"In the snippet above we implement a ",(0,s.kt)("inlineCode",{parentName:"p"},"sudo")," entrypoint to catch all the ",(0,s.kt)("inlineCode",{parentName:"p"},"KVQueryResult")," callbacks, and we define\n",(0,s.kt)("inlineCode",{parentName:"p"},"sudo_kv_query_result")," handler to process the callback. In this particular handler we don't anything, but print some debug info to the log.\nBut there could be any logic you want."),(0,s.kt)("h3",{id:"get-results-from-tx-queries"},"Get results from TX-queries"),(0,s.kt)("p",null,"Unlike KV-queries result, TX-queries results are not saved to the module storage by the Neutron ICQ Module (on Cosmos-SDK level).\nTX-queries are supported only in ",(0,s.kt)("em",{parentName:"p"},"callback way"),", so to get result from TX-queries you have to work with ",(0,s.kt)("inlineCode",{parentName:"p"},"sudo")," callbacks and save results to the storage by yourself if you need:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#[entry_point]\npub fn sudo(deps: DepsMut<NeutronQuery>, env: Env, msg: SudoMsg) -> NeutronResult<Response> {\n    match msg {\n        SudoMsg::TxQueryResult {\n            query_id,\n            height,\n            data,\n        } => sudo_tx_query_result(deps, env, query_id, height, data)\n    }\n}\n\n/// sudo_check_tx_query_result is an example callback for transaction query results that stores the\n/// deposits received as a result on the registered query in the contract\'s state.\npub fn sudo_tx_query_result(\n    deps: DepsMut<NeutronQuery>,\n    _env: Env,\n    query_id: u64,\n    _height: u64,\n    data: Binary,\n) -> NeutronResult<Response> {\n    // Decode the transaction data\n    let tx: TxRaw = TxRaw::decode(data.as_slice())?;\n    let body: TxBody = TxBody::decode(tx.body_bytes.as_slice())?;\n\n    // Get the registered query by ID and retrieve the raw query string\n    let registered_query: QueryRegisteredQueryResponse =\n        get_registered_query(deps.as_ref(), query_id)?;\n    let transactions_filter = registered_query.registered_query.transactions_filter;\n\n    #[allow(clippy::match_single_binding)]\n    // Depending of the query type, check the transaction data to see whether is satisfies\n    // the original query. If you don\'t write specific checks for a transaction query type,\n    // all submitted results will be treated as valid.\n    match registered_query.registered_query.query_type {\n        _ => {\n            // For transfer queries, query data looks like `[{"field:"transfer.recipient", "op":"eq", "value":"some_address"}]`\n            let query_data: Vec<TransactionFilterItem> =\n                serde_json_wasm::from_str(transactions_filter.as_str())?;\n\n            let recipient = query_data\n                .iter()\n                .find(|x| x.field == RECIPIENT_FIELD && x.op == TransactionFilterOp::Eq)\n                .map(|x| match &x.value {\n                    TransactionFilterValue::String(v) => v.as_str(),\n                    _ => "",\n                })\n                .unwrap_or("");\n\n            let deposits = recipient_deposits_from_tx_body(body, recipient)?;\n            // If we didn\'t find a Send message with the correct recipient, return an error, and\n            // this query result will be rejected by Neutron: no data will be saved to state.\n            if deposits.is_empty() {\n                return Err(NeutronError::Std(StdError::generic_err(\n                    "failed to find a matching transaction message",\n                )));\n            }\n\n            let mut stored_transfers: u64 = TRANSFERS.load(deps.storage).unwrap_or_default();\n            stored_transfers += deposits.len() as u64;\n            TRANSFERS.save(deps.storage, &stored_transfers)?;\n\n            check_deposits_size(&deposits)?;\n            let mut stored_deposits: Vec<Transfer> = RECIPIENT_TXS\n                .load(deps.storage, recipient)\n                .unwrap_or_default();\n            stored_deposits.extend(deposits);\n            RECIPIENT_TXS.save(deps.storage, recipient, &stored_deposits)?;\n            Ok(Response::new())\n        }\n    }\n}\n')),(0,s.kt)("p",null,"In the snippet above we implement a ",(0,s.kt)("inlineCode",{parentName:"p"},"sudo")," entrypoint to catch all the ",(0,s.kt)("inlineCode",{parentName:"p"},"TXQueryResult")," callbacks, and we define\n",(0,s.kt)("inlineCode",{parentName:"p"},"sudo_tx_query_result")," handler to process the callback.\nIn the handler we decode the transaction data at first, try to parse messages in the transaction, check that transaction really satisfies our defined filter\nand do some business logic (in our case we just save transfer to the storage and increase the total incoming transfers number)."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"IMPORTANT NOTICE:")," It's necessary to check that the result transaction satisfies your filter. Although Neutron guarantees that transaction is valid\n(meaning transaction is really included in a block on remote chain, it was executed successfully, signed properly, etc.), Neutron ",(0,s.kt)("em",{parentName:"p"},"can not")," guarantee you\nthat result transaction satisifies defined filter. You must always check this in your contract!")),(0,s.kt)("p",null,"Just like with the KV query (the Balance one), TX query results can be retrieved by the contract state. In this respect there is no difference between query types, it's only matter of the way you design your contracts."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"/// Returns the number of transfers made on remote chain and queried with ICQ\nfn query_transfers_number(deps: Deps<NeutronQuery>) -> NeutronResult<Binary> {\n    let transfers_number = TRANSFERS.load(deps.storage).unwrap_or_default();\n    Ok(to_binary(&GetTransfersAmountResponse { transfers_number })?)\n}\n")),(0,s.kt)("h2",{id:"4-manage-registered-interchain-queries"},"4. Manage registered Interchain Queries"),(0,s.kt)("p",null,"In some cases you may need to update Interchain Queries parameters (update period, KV-keys, tx filter, etc) or even remove a\nquery from the Neutron.\nNeutron allows you to do these actions via ",(0,s.kt)("inlineCode",{parentName:"p"},"Update")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Remove")," messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use neutron_sdk::bindings::msg::NeutronMsg;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n    ...\n    UpdateInterchainQuery {\n        query_id: u64,\n        new_keys: Option<Vec<KVKey>>,\n        new_update_period: Option<u64>,\n    },\n    RemoveInterchainQuery {\n        query_id: u64,\n    },\n    ...\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    deps: DepsMut<NeutronQuery>,\n    env: Env,\n    _: MessageInfo,\n    msg: ExecuteMsg,\n) -> NeutronResult<Response<NeutronMsg>> {\n    match msg {\n        ...\n        ExecuteMsg::UpdateInterchainQuery {\n            query_id,\n            new_keys,\n            new_update_period,\n            new_recipient,\n        } => update_interchain_query(query_id, new_keys, new_update_period, new_recipinet),\n        ExecuteMsg::RemoveInterchainQuery { query_id } => remove_interchain_query(query_id),\n        ...\n    }\n}\n\npub fn update_interchain_query(\n    query_id: u64,\n    new_keys: Option<Vec<KVKey>>,\n    new_update_period: Option<u64>,\n    new_recipient: Option<String>,\n) -> NeutronResult<Response<NeutronMsg>> {\n    let new_filter = new_recipient.map(|recipient| {\n        vec![TransactionFilterItem {\n            field: RECIPIENT_FIELD.to_string(),\n            op: TransactionFilterOp::Eq,\n            value: TransactionFilterValue::String(recipient),\n        }]\n    });\n\n    let update_msg = NeutronMsg::update_interchain_query(query_id, new_keys, new_update_period, new_filter);\n    Ok(Response::new().add_message(update_msg))\n}\n\npub fn remove_interchain_query(query_id: u64) -> NeutronResult<Response<NeutronMsg>> {\n    let remove_msg = NeutronMsg::remove_interchain_query(query_id);\n    Ok(Response::new().add_message(remove_msg))\n}\n')),(0,s.kt)("p",null,"In the snippet above we add ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateInterchainQuery")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"RemoveInterchainQuery")," to our ",(0,s.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," enum and define corresponding\nhandlers ",(0,s.kt)("inlineCode",{parentName:"p"},"update_interchain_query")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"remove_interchain_query")," which, in short, just issue proper ",(0,s.kt)("a",{parentName:"p",href:"/neutron/modules/interchain-queries/messages"},"Neutron msgs")," to update and remove interchain query.\nIn a real world scenario such handlers must have ownership checks."),(0,s.kt)("h2",{id:"learning-to-make-your-own-queries-that-are-not-in-neutron-sdk"},"Learning to make your own queries that are not in Neutron SDK"),(0,s.kt)("p",null,"Same as in the examples above, to make a query, you need to populate KVKey struct:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct KVKey {\n    /// **path** is a path to the storage (storage prefix) where you want to read value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)\n    pub path: String,\n\n    /// **key** is a key you want to read from the storage\n    pub key: Binary,\n};\n")),(0,s.kt)("p",null,"Let's say we want to make interchain query to wasmd module for contract info.\nFirst thing to understand is that you need to know exact version of that module on a chain that you want to query for data.\nLet's assume we'll query osmosis testnet (osmo-test-5 testnet).\nHere we discover that chain uses ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/testnets/tree/main/testnets/osmo-test-5#details"},(0,s.kt)("inlineCode",{parentName:"a"},"v16.0.0-rc2-testnet")," version"),".\nAs we can see this version of osmosis uses ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/v16.0.0-rc2-testnet/go.mod#L320"},"custom patched wasmd module"),"."),(0,s.kt)("p",null,"Now that we have found ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/tree/v0.31.0-osmo-v16"},"this wasmd module"),", let's understand how the cosmos-sdk stores data. To simplify: Cosmos SDK ",(0,s.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/main/core/store"},"store")," keeps data as a self-balancing tree where key is an array of bytes. In that tree you can fetch list of elements that share a common prefix and a concrete element if you concatenate prefix with the element key.\nUsually we'll look into ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/keeper/keeper.go"},"keeper.go")," and other files in the ",(0,s.kt)("inlineCode",{parentName:"p"},"keeper")," package to see where and what kind of data it keeps in a store.\nLet's say we want to fetch contract info data. If you look for where contract info is being set, you'll find the store.Set ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/keeper/keeper.go#L749"},"here"),", that sets the contract info under the key ",(0,s.kt)("inlineCode",{parentName:"p"},"types.GetContractAddressKey(contractAddress)"),".\nThis function is imported using the keys file and it is a common place for storing all key creation helpers. It's usually placed at ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/types/keys.go"},"/x/modulename/types/keys.go"),".\nAs we can see the key in store is simply ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/blob/master/x/wasm/types/keys.go#L48"},"concatenation of ContractKeyPrefix ([]byte{0x02}) and address of the contract that you want to query"),"."),(0,s.kt)("p",null,"Now that we now how to create the key, we can rebuild it's creation using rust in cosmwasm:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/types/keys.go#L28\npub const CONTRACT_KEY_PREFIX: u8 = 0x02;\n\nfn create_contract_address_info_key(addr: AddressBytes) -> StdResult<AddressBytes> {\n    let mut key: Vec<u8> = vec![CONTRACT_KEY_PREFIX];\n    // https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/types/keys.go#L49\n    key.extend_from_slice(addr.as_slice());\n\n    Ok(key)\n}\n")),(0,s.kt)("p",null,"After that we can write use this key in a function that will create message to register this query:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use neutron_sdk::interchain_queries::helpers::decode_and_convert;\nuse neutron_sdk::interchain_queries::types::QueryPayload;\nuse neutron_sdk::bindings::types::KVKey;\nuse neutron_sdk::bindings::msg::NeutronMsg;\nuse cosmwasm_std::Binary;\n\n// https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/types/keys.go#L13\npub const WASM_STORE_KEY: &str = "wasm";\n\npub fn new_register_contract_address_info_query_msg(\n    connection_id: String,\n    addr: String,\n    update_period: u64,\n) -> NeutronResult<NeutronMsg> {\n    // We need to decode a bech32 encoded string and converts to base64 encoded bytes.\n    // This is needed since addresses are stored this way in Cosmos SDK.\n    let converted_addr_bytes = decode_and_convert(addr.as_str())?;\n\n    let balance_key = create_contract_address_info_key(converted_addr_bytes)?;\n\n    let kv_key = KVKey {\n        // Path to store, in our case its store of wasmd module (https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/x/wasm/types/keys.go#L13)\n        path: WASM_STORE_KEY.to_string(),\n        key: Binary(balance_key),\n    };\n\n    // Construct NeutronMsg to register interchain query with our constructed kv_key key, connection_id and update_period\n    NeutronMsg::register_interchain_query(\n        QueryPayload::KV(vec![kv_key]),\n        connection_id,\n        update_period,\n    )\n}\n')),(0,s.kt)("p",null,"By this point we've learned how to register a query with correct key.\nNow to get some meaningful results, you'll need to understand how to get query results.\nFor that you'll need to implement reconstruction of results using ",(0,s.kt)("inlineCode",{parentName:"p"},"KVReconstruct")," trait.\nThis trait has one function ",(0,s.kt)("inlineCode",{parentName:"p"},"reconstruct")," that takes raw ",(0,s.kt)("inlineCode",{parentName:"p"},"&[StorageValue]")," as an input and returns ",(0,s.kt)("inlineCode",{parentName:"p"},"NeutronResult<YourStruct>"),".\nArgument into the function will have as many items in it as you'll sent keys when registered the query.\nIn our case it's length will be 1."),(0,s.kt)("p",null,"These values are stored as a protobuf encoded value.\nTo decode it we'll need to find or describe the type for the protobuf value in rust code."),(0,s.kt)("p",null,"First find the protobuf type that is used to store the value.\n",(0,s.kt)("inlineCode",{parentName:"p"},"ContractInfo")," is stored ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/wasmd/blob/v0.31.0-osmo-v16/proto/cosmwasm/wasm/v1/types.proto#L75"},"here"),".\nThere you have two choises:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Use already available implementations - for osmosis they have osmosis-std lib with our type ","[see this]"," (",(0,s.kt)("a",{parentName:"li",href:"https://github.com/osmosis-labs/osmosis-rust/blob/v0.16.1/packages/osmosis-std/src/types/cosmwasm/wasm/v1.rs#L301)"},"https://github.com/osmosis-labs/osmosis-rust/blob/v0.16.1/packages/osmosis-std/src/types/cosmwasm/wasm/v1.rs#L301)"),";"),(0,s.kt)("li",{parentName:"ul"},"Write your own prost protobuf implementation.")),(0,s.kt)("p",null,"First you'll need to import required libs:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-toml"},'osmosis-std = { version = "0.16.1" }\n')),(0,s.kt)("p",null,"Then you can implement KVReconstruct like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use osmosis_std::types::cosmwasm::wasm::v1::ContractInfo as OsmosisContractInfo;\nuse neutron_sdk::interchain_queries::types::KVReconstruct;\nuse neutron_sdk::bindings::types::StorageValue;\nuse neutron_sdk::{NeutronError, NeutronResult};\n\nimpl KVReconstruct for ContractInfo {\n    fn reconstruct(storage_values: &[StorageValue]) -> NeutronResult<ContractInfo> {\n        // our query has one key, that means we expect only one item in the slice\n        if storage_values.len() != 1 {\n            return Err(Std(StdError::generic_err(format!(\n                "Not one storage value returned for ContractInfo response: {:?}",\n                storage_values.len()\n            ))));\n        }\n        // take first key\n        let kv = storage_values\n            .first()\n            .ok_or(Std(StdError::generic_err(format!(\n                "Not one storage value returned for ContractInfo response: {:?}",\n                storage_values.len()\n            ))))?;\n        // decode binary value into protobuf struct\n        let osmosis_res = OsmosisContractInfo::decode(kv.value.as_slice())?;\n\n        // construct result using decoded struct\n        let res = ContractInfo {\n            code_id: osmosis_res.code_id,\n            creator: osmosis_res.creator,\n            admin: osmosis_res.admin,\n            label: osmosis_res.label,\n            created: osmosis_res.created.map(|p| AbsoluteTxPosition {\n                block_height: p.block_height,\n                tx_index: p.tx_index,\n            }),\n            ibc_port_id: osmosis_res.ibc_port_id,\n        };\n\n        Ok(res)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub struct ContractInfo {\n    // CodeID is the reference to the stored Wasm code\n    pub code_id: u64,\n    // Creator address who initially instantiated the contract\n    pub creator: String,\n    // Admin is an optional address that can execute migrations\n    pub admin: String,\n    // Label is optional metadata to be stored with a contract instance.\n    pub label: String,\n    // Created Tx position when the contract was instantiated.\n    pub created: Option<AbsoluteTxPosition>,\n    pub ibc_port_id: String,\n}\n\n// AbsoluteTxPosition is a unique transaction position that allows for global\n// ordering of transactions.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub struct AbsoluteTxPosition {\n    // BlockHeight is the block the contract was created at\n    pub block_height: u64,\n    // TxIndex is a monotonic counter within the block (actual transaction index,\n    // or gas consumed)\n    pub tx_index: u64,\n}\n')),(0,s.kt)("p",null,"Now that our ContractInfo implements KVReconstruct, we can try to check that it's working properly.\nFor that we can write something analogous to the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/main/packages/neutron-sdk/src/interchain_queries/v045/testing.rs#L762"},"testing.rs test_balance_reconstruct_from_hex"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use base64::prelude::*;\nuse base64::Engine;\n\npub const BALANCES_HEX_RESPONSE: &str = "TODO!"; // see the code below on how to find this value\n\n#[test]\nfn test_balance_reconstruct_from_hex() {\n    let bytes = hex::decode(BALANCES_HEX_RESPONSE).unwrap(); // decode hex string to bytes\n    let base64_input = BASE64_STANDARD.encode(bytes); // encode bytes to base64 string\n\n    let s = StorageValue {\n        storage_prefix: String::default(), // not used in reconstruct\n        key: Binary::default(),            // not used in reconstruct\n        value: Binary::from_base64(base64_input.as_str()).unwrap(),\n    };\n    let bank_balances = Balances::reconstruct(&[s]).unwrap();\n    assert_eq!(\n        bank_balances,\n        Balances {\n            coins: vec![StdCoin {\n                denom: String::from("stake"),\n                amount: Uint128::from(99999000u64),\n            }]\n        }\n    );\n')),(0,s.kt)("p",null,"Not that to write a test we need an example of HEX response for our function that we'll use for ",(0,s.kt)("inlineCode",{parentName:"p"},"BALANCES_HEX_RESPONSE")," constant.\nTo do that you'll need to get value using ",(0,s.kt)("inlineCode",{parentName:"p"},"RPC_PATH/abci_query")," GET request with your contructed key and store.\n`",(0,s.kt)("inlineCode",{parentName:"p"}),"data` is your KV key in HEX representation of the binary.\nTo construct the key, you can run this code somewhere:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use neutron_sdk::interchain_queries::helpers::decode_and_convert;\n\nlet addr = "osmo14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sq2r9g9";\nlet converted_addr_bytes = decode_and_convert(addr).unwrap();\n// your newly written `create_contract_address_info_key` function\nlet actual = create_contract_address_info_key(converted_addr_bytes).unwrap();\nprintln!("{:?}", hex::encode(actual))\n')),(0,s.kt)("p",null,"Then using ",(0,s.kt)("a",{parentName:"p",href:"https://rpc.testnet.osmosis.zone/abci_query?path=%22%2Fstore%2Fwasm%2Fkey%22&data=0x02ade4a5f5803a439835c636395a8d648dee57b2fc90d98dc17fa887159b69638b"},"abci_query with this key")," you can write a test named ",(0,s.kt)("inlineCode",{parentName:"p"},"test_contract_info_reconstruct()")," that will use returned value as an input to ContractInfo::reconstruct."),(0,s.kt)("p",null,"See whole test implementation below:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::Binary;\nuse crate::bindings::types::StorageValue;\nuse neutron_sdk::interchain_queries::helpers::decode_and_convert;\nuse neutron_sdk::interchain_queries::types::KVReconstruct;\n\nconst ABCI_KEY: &str = "02ade4a5f5803a439835c636395a8d648dee57b2fc90d98dc17fa887159b69638b";\nconst ABCI_RESULT: &str = "CAESK29zbW8xcWxtd2prZzd1dTRhd2FqdzVhdW5jdGpkY2U5cTY1N2ozMm54czIiCk9zbW81X1Bhd3MqBAiy9g4=";\n\n#[test]\nfn test_contract_info_reconstruct() {\n    let value = base64::decode(ABCI_RESULT).unwrap();\n    let input = StorageValue {\n        storage_prefix: "wasm".to_string(),\n        key: Binary::from(vec![]),\n        value: Binary::from(value),\n    };\n    let contract_info = ContractInfo::reconstruct(&vec![input]);\n    assert!(contract_info.is_ok());\n    assert_eq!(contract_info.unwrap(), ContractInfo {\n        code_id: 1,\n        creator: "osmo1qlmwjkg7uu4awajw5aunctjdce9q657j32nxs2".to_string(),\n        admin: "".to_string(),\n        label: "Osmo5_Paws".to_string(),\n        created: Some(AbsoluteTxPosition { block_height: 244530, tx_index: 0 }),\n        ibc_port_id: "".to_string(),\n    })\n}\n')),(0,s.kt)("p",null,"Great! Now you can query ",(0,s.kt)("inlineCode",{parentName:"p"},"ContractInfo")," as simple as this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"use neutron_sdk::interchain_queries::query_kv_result;\n\nlet contract_info: ContractInfo = query_kv_result(deps, query_id)?;\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"WARN: please look into correct version of chain when you search on how keys and data model are stored. Otherwise key construction AND/OR data model can change and you'll fail to query data OR reconstruct it!\nFor example, you can see that in ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.45.11-ics/x/bank/keeper/send.go#L262"},"v0.45.11-ics")," sets balance as ",(0,s.kt)("inlineCode",{parentName:"p"},"Coin")," type and in ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.46.11/x/bank/keeper/send.go#L290"},"v0.46.11")," it sets only the amount as a ",(0,s.kt)("inlineCode",{parentName:"p"},"String")," type. So if you don't change the KVReconstruct for this value, it'll break.")))}p.isMDXComponent=!0}}]);