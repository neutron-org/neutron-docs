"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[6355],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(n),d=r,h=p["".concat(c,".").concat(d)]||p[d]||m[d]||o;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},98072:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={},s="Messages",i={unversionedId:"neutron/modules/interchain-txs/messages",id:"neutron/modules/interchain-txs/messages",title:"Messages",description:"MsgRegisterInterchainAccount",source:"@site/docs/neutron/modules/interchain-txs/messages.md",sourceDirName:"neutron/modules/interchain-txs",slug:"/neutron/modules/interchain-txs/messages",permalink:"/neutron/modules/interchain-txs/messages",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Overview",permalink:"/neutron/modules/interchain-txs/overview"},next:{title:"Client",permalink:"/neutron/modules/interchain-txs/client"}},c={},l=[{value:"MsgRegisterInterchainAccount",id:"msgregisterinterchainaccount",level:2},{value:"Response",id:"response",level:3},{value:"IBC Events",id:"ibc-events",level:3},{value:"State modifications",id:"state-modifications",level:3},{value:"MsgSubmitTx",id:"msgsubmittx",level:2},{value:"Response",id:"response-1",level:3},{value:"IBC Events",id:"ibc-events-1",level:3},{value:"State modifications",id:"state-modifications-1",level:3}],u={toc:l},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"messages"},"Messages"),(0,r.kt)("h2",{id:"msgregisterinterchainaccount"},"MsgRegisterInterchainAccount"),(0,r.kt)("p",null,"Attempts to register an interchain account by sending an IBC packet over an IBC connection."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},'message MsgRegisterInterchainAccount {\n  option (gogoproto.equal) = false;\n  option (gogoproto.goproto_getters) = false;\n\n  string from_address = 1;\n  string connection_id = 2 [ (gogoproto.moretags) = "yaml:\\"connection_id\\"" ];\n  string interchain_account_id = 3 [ (gogoproto.moretags) = "yaml:\\"interchain_account_id\\"" ];\n  repeated cosmos.base.v1beta1.Coin register_fee = 4;\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from_address")," must be a smart contract address, otherwise the message will fail;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"connection_id")," must be the identifier of a valid IBC connection, otherwise the message will fail;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"interchain_account_id")," is used to generate the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/ibc-go/blob/v3.1.1/modules/apps/27-interchain-accounts/controller/keeper/account.go#L17"},"owner")," parameter for ICA's ",(0,r.kt)("inlineCode",{parentName:"li"},"RegisterInterchainAccount()")," call, which is later used for port identifier generation (see below). Maximum allowed length of ",(0,r.kt)("inlineCode",{parentName:"li"},"interchain_account_id")," is 47 characters."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"register_fee")," fee is required to be paid in favor of the community (payee address is the treasury) to register an interchain account. Minimal amount of fee is contolled by the module's param ",(0,r.kt)("inlineCode",{parentName:"li"},"RegisterFee"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"IBC ports naming / Interchain Account address derivation"),(0,r.kt)("p",null,"If a contract with the address ",(0,r.kt)("inlineCode",{parentName:"p"},"neutron14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9s5c2epq")," sends an ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgRegisterInterchainAccount")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"interchain_account_id")," set to ",(0,r.kt)("inlineCode",{parentName:"p"},"hub/1"),", the generated ICA owner will look like ",(0,r.kt)("inlineCode",{parentName:"p"},"neutron14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9s5c2epq.hub/1"),", and the IBC port generated by the ICA app will be equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"icacontroller-neutron14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9s5c2epq.hub/1"),".")),(0,r.kt)("details",null,(0,r.kt)("summary",null," Neutron V2 update: Fee Implementation for ICA Registration"),(0,r.kt)("p",null,"As of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron/releases/tag/v2.0.0"},"Neutron V2"),", we have introduced a new fee structure for the registration of Interchain Accounts (ICAs). Please be aware of the following updates:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://github.com/neutron-org/neutron/blob/c6df465e5f83a811fd1cc98b6ebbf677a55ea21c/x/interchaintxs/types/params.pb.go#L32"},"Minimum Fee (minFee)"),":")," A minimum fee is now required for all new ICA registrations. This fee goes directly to the ",(0,r.kt)("inlineCode",{parentName:"p"},"FeeCollector")," with purpose of preventing spam.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"FeeCollector Beneficiary"),":")," The ",(0,r.kt)("inlineCode",{parentName:"p"},"FeeCollector")," is the designated recipient of the new registration fees, ensuring the economic sustainability of the network. This is the Neutron DAO at the moment.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Backwards Compatibility Assurance:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Contracts and ICAs established with contracts, stored on Neutron before ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron/releases/tag/v2.0.0"},"V2")," ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron/blob/c6df465e5f83a811fd1cc98b6ebbf677a55ea21c/x/interchaintxs/keeper/msg_server.go#L51"},"will ",(0,r.kt)("strong",{parentName:"a"},"not"))," incur the new registration fee."),(0,r.kt)("li",{parentName:"ul"},"This update is fully compatible with previous ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/neutron/releases/tag/v1.0.4"},"Neutron V1 version"),", guaranteeing a smooth transition and no disruption to existing contracts and services.")))),(0,r.kt)("p",null,"ICA's remote address generation concatenates connection identifier and port identifier to use them as the derivation key for the new account:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// GenerateAddress returns an sdk.AccAddress derived using the provided module account address and connection and port identifiers.\n// The sdk.AccAddress returned is a sub-address of the module account, using the host chain connection ID and controller chain's port ID as the derivation key\nfunc GenerateAddress(moduleAccAddr sdk.AccAddress, connectionID, portID string) sdk.AccAddress {\n    return sdk.AccAddress(sdkaddress.Derive(moduleAccAddr, []byte(connectionID+portID)))\n}\n"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," your contract needs to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"sudo()")," entrypoint on order to successfully process the IBC events associated with this message. You can find an example in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/tree/main/contracts"},"neutron-sdk")," repository.")),(0,r.kt)("h3",{id:"response"},"Response"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgRegisterInterchainAccountResponse {}\n")),(0,r.kt)("h3",{id:"ibc-events"},"IBC Events"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type MessageOnChanOpenAck struct {\n    OpenAck OpenAckDetails `json:"open_ack"`\n}\n\ntype OpenAckDetails struct {\n    PortID                string `json:"port_id"`\n    ChannelID             string `json:"channel_id"`\n    CounterpartyChannelId string `json:"counterparty_channel_id"`\n    CounterpartyVersion   string `json:"counterparty_version"`\n}\n')),(0,r.kt)("p",null,"The data from an ",(0,r.kt)("inlineCode",{parentName:"p"},"OnChanOpenAck")," event is passed to the contract using a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd/blob/288609255ad92dfe5c54eae572fe7d6010e712eb/x/wasm/keeper/keeper.go#L453"},"Sudo() call"),". You can have a look at an example handler implementation in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/tree/main/contracts"},"neutron-sdk")," repository."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: you can find the interchain account address in the stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CounterpartyVersion")," field as part of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/27-interchain-accounts/host/keeper/handshake.go#L78"},"metadata"),".")),(0,r.kt)("h3",{id:"state-modifications"},"State modifications"),(0,r.kt)("p",null,"None."),(0,r.kt)("h2",{id:"msgsubmittx"},"MsgSubmitTx"),(0,r.kt)("p",null,"Attempts to execute a transaction on a remote chain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgSubmitTx {\n  option (gogoproto.equal) = false;\n  option (gogoproto.goproto_getters) = false;\n\n  string from_address = 1;\n  string interchain_account_id = 2;\n  string connection_id = 3;\n  repeated google.protobuf.Any msgs = 4;\n  string memo = 5;\n  uint64 timeout = 6;\n\n  neutron.feerefunder.Fee fee = 7 [ (gogoproto.nullable) = false ];\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from_address")," must be a smart contract address, otherwise the message will fail;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"interchain_account_id")," is identical to ",(0,r.kt)("inlineCode",{parentName:"li"},"MsgRegisterInterchainAccount.interchain_account_id"),";"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"connection_id")," must be the identifier of a valid IBC connection, otherwise the message will fail;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"msgs")," must contain not more than it is defined in the module params;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"memo")," is the transaction ",(0,r.kt)("a",{parentName:"li",href:"https://docs.cosmos.network/master/core/transactions.html"},"memo"),";"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timeout")," is a timeout in seconds after which the packet times out;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fee")," is a fee amount to refund relayer for ",(0,r.kt)("inlineCode",{parentName:"li"},"ack")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"timeout")," messages submission.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," your smart-contract ",(0,r.kt)("strong",{parentName:"p"},"must have")," ",(0,r.kt)("inlineCode",{parentName:"p"},"fee.ack_fee + fee.timeout_fee + fee.recv_fee")," coins on its balance, otherwise the message fails. See more info about fee refunding mechanism ",(0,r.kt)("a",{parentName:"p",href:"../feerefunder/overview#general-mechanics"},"here"),".")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," most networks reject memos longer than 256 bytes.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," your contract needs to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"sudo()")," entrypoint on order to successfully process the IBC events associated with this message. You can find an example in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/tree/main/contracts"},"neutron-sdk")," repository.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," to see the currently available messages amount in a single MsgSubmitTx, query the module parameters:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'neutrond query interchaintxs params\n\nparams:\n  msg_submit_tx_max_messages: "16"\n')),(0,r.kt)("h3",{id:"response-1"},"Response"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgSubmitTxResponse {\n  uint64 sequence_id = 1;\n  string channel = 2;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sequence_id")," is a channel's sequence_id for outgoing ibc packet. Unique per a channel;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"channel")," is the src channel name on neutron's side trasaction was submitted from;")),(0,r.kt)("h3",{id:"ibc-events-1"},"IBC Events"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// MessageSudoCallback is passed to a contract\'s sudo() entrypoint when an interchain\n// transaction failed.\ntype MessageSudoCallback struct {\n    Response *ResponseSudoPayload `json:"response,omitempty"`\n    Error    *ErrorSudoPayload    `json:"error,omitempty"`\n    Timeout  *TimeoutPayload      `json:"timeout,omitempty"`\n}\n\ntype ResponseSudoPayload struct {\n    Request channeltypes.Packet `json:"request"`\n    Data    []byte              `json:"data"` // Message data\n}\n\ntype ErrorSudoPayload struct {\n    Request channeltypes.Packet `json:"request"`\n    Details string              `json:"details"`\n}\n\ntype TimeoutPayload struct {\n    Request channeltypes.Packet `json:"request"`\n}\n')),(0,r.kt)("p",null,"While trying to execute an interchain transaction, you can receive an IBC ",(0,r.kt)("inlineCode",{parentName:"p"},"Timeout")," or an IBC ",(0,r.kt)("inlineCode",{parentName:"p"},"Acknowledgement"),", and the latter can contain either a valid response or an error. These three types of transaction results are passed to the contract as distinct messages using a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd/blob/288609255ad92dfe5c54eae572fe7d6010e712eb/x/wasm/keeper/keeper.go#L453"},"Sudo() call"),". You can have a look at an example handler implementation in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/tree/main/contracts"},"neutron-sdk")," repository."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),": there is no dedicated event for a closed channel (ICA disables all messages related to closing the channels)\n. Your channel, however, can still be closed if a packet timeout occurs; thus, if you are notified about a packet\ntimeout, you can be sure that the affected channel was closed. Please note that it is generally a good practice to set\nthe packet timeout for your interchain transactions to a really large value."),(0,r.kt)("p",{parentName:"blockquote"},"If the timeout occurs anyway, you can just\nexecute ",(0,r.kt)("a",{parentName:"p",href:"/neutron/modules/interchain-txs/messages#msgregisterinterchainaccount"},"RegisterInterchainAccount message")," again to\nrecover access to your interchain account.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")," Keep in mind, new channel is created")),(0,r.kt)("p",null,"You can more find info, recommendations and examples about how process acknowledgements ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/neutron-sdk/blob/6e7e83d3083f7942942ff0d97a36f9e9f00d4aee/contracts/neutron_interchain_txs/src/contract.rs#L397"},"here"),"."),(0,r.kt)("h3",{id:"state-modifications-1"},"State modifications"),(0,r.kt)("p",null,"None."))}m.isMDXComponent=!0}}]);