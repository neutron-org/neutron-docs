"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[4713],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),p=r,g=d["".concat(l,".").concat(p)]||d[p]||m[p]||o;return n?a.createElement(g,s(s({ref:t},u),{},{components:n})):a.createElement(g,s({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},90408:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={},s="Part 2: Calling Modules and Contracts",i={unversionedId:"tutorials/onboarding/part-2-calling-modules-and-contracts",id:"tutorials/onboarding/part-2-calling-modules-and-contracts",title:"Part 2: Calling Modules and Contracts",description:"Overview",source:"@site/docs/tutorials/onboarding/part-2-calling-modules-and-contracts.md",sourceDirName:"tutorials/onboarding",slug:"/tutorials/onboarding/part-2-calling-modules-and-contracts",permalink:"/tutorials/onboarding/part-2-calling-modules-and-contracts",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Part 1: Minimal Application",permalink:"/tutorials/onboarding/part-1-minimal-application"},next:{title:"Part 3: Building a simple Web Application",permalink:"/tutorials/onboarding/part-3-building-simple-web-app"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Smart contracts",id:"smart-contracts",level:2},{value:"Sending messages to smart contracts, processing the responses and making queries to other contract",id:"sending-messages-to-smart-contracts-processing-the-responses-and-making-queries-to-other-contract",level:3},{value:"Instantiation of the contract",id:"instantiation-of-the-contract",level:4},{value:"Contract execution",id:"contract-execution",level:4},{value:"Modules",id:"modules",level:2},{value:"Sending Messages to Cosmos SDK Modules",id:"sending-messages-to-cosmos-sdk-modules",level:3},{value:"Interacting with the contract",id:"interacting-with-the-contract",level:2},{value:"Compile the contract binary",id:"compile-the-contract-binary",level:3},{value:"Upload the contract",id:"upload-the-contract",level:3},{value:"Interact with the contract",id:"interact-with-the-contract",level:3},{value:"Increase counter in the Minimal Contract",id:"increase-counter-in-the-minimal-contract",level:5},{value:"Send NTRNs to some address",id:"send-ntrns-to-some-address",level:5}],u={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"part-2-calling-modules-and-contracts"},"Part 2: Calling Modules and Contracts"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"In the previous part of this tutorial we learned how to implement a simple contract that manages its own state.\nReal-world applications, however, are rarely that simple; in order to implement something\nuseful, you need to know how to interact with ",(0,r.kt)("strong",{parentName:"p"},"other smart contracts")," and with Neutron ",(0,r.kt)("strong",{parentName:"p"},"modules"),"."),(0,r.kt)("h2",{id:"smart-contracts"},"Smart contracts"),(0,r.kt)("p",null,"Technically speaking, executing and querying other smart contracts from your own smart contract involves sending\nmessages to the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmd")," module, but the interface of this interaction is slightly different from what you will need to\ndo with other modules."),(0,r.kt)("p",null,"There are 3 things to cover here:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Sending messages to smart contracts,"),(0,r.kt)("li",{parentName:"ol"},"Processing responses to those messages,"),(0,r.kt)("li",{parentName:"ol"},"Querying data from smart contracts.")),(0,r.kt)("h3",{id:"sending-messages-to-smart-contracts-processing-the-responses-and-making-queries-to-other-contract"},"Sending messages to smart contracts, processing the responses and making queries to other contract"),(0,r.kt)("p",null,"In CosmWasm, sending messages from one contract to another is typically done using the ",(0,r.kt)("inlineCode",{parentName:"p"},"WasmMsg::Execute")," variant within\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"CosmosMsg"),". This allows you to execute an action on another contract by sending data (like tokens or structured\ninstructions) to the target contract."),(0,r.kt)("p",null,"Let's create a new simple contract to interact with the contract from\nthe ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/onboarding/part-1-minimal-application"},"previous chapter:"),", which calls ",(0,r.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," method of the\nMinimal Contract."),(0,r.kt)("h4",{id:"instantiation-of-the-contract"},"Instantiation of the contract"),(0,r.kt)("p",null,"Since we decided that our contract should interact with the Minimal Contract from the previous part, our contract must\nstore its address somewhere. Let's create a simple config where the address will be stored and we will save the address\nof the Minimal contract during instantiation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub const CONFIG: Item<Config> = Item::new("config");\n\n/// Any data that is necessary to set up your new contract should be added\n/// here.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct InstantiateMsg {\n    // an address of the minimal contract instance\n    pub minimal_contract_address: Addr,\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response<NeutronMsg>, ContractError> {\n    // save minimal contract address to config\n    CONFIG.save(\n        deps.storage,\n        &Config {\n            minimal_contract_address: msg.minimal_contract_address,\n        },\n    )?;\n\n    Ok(Response::new()\n        // We add some attributes to the response with information about the current call.\n        // It\'s useful for debugging.\n        .add_attribute("action", "instantiate")\n        .add_attribute("contract_address", env.contract.address)\n        .add_attribute("sender", info.sender.to_string()))\n}\n')),(0,r.kt)("h4",{id:"contract-execution"},"Contract execution"),(0,r.kt)("p",null,"Now let's implement the core logic of our contract that calls the Minimal contract instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::{CosmosMsg, WasmMsg, to_json_binary, Response, DepsMut, Env, MessageInfo};\nuse cw_storage_plus::Item;\n\npub fn send_message_to_contract(deps: DepsMut, amount: Uint128) -> Result<Response, ContractError> {\n    // read the config from, a storage\n    let config = CONFIG.load(deps.storage)?;\n\n    // here we compose a message to a minimal contract instance to increase a counter there by specified amount\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.minimal_contract_address.into_string(), // call the minimal contract by its address\n        msg: to_json_binary(&MinimalContractExecuteMsg::IncreaseCount { amount })?,\n        funds: vec![], // Optionally, you can send funds along with the message.\n    });\n\n    Ok(Response::new()\n        .add_message(message)\n        .add_attribute("action", "send_message_to_contract"))\n}\n')),(0,r.kt)("p",null,"This is it! This simple construction allows to call any method of any contract on Neutron. But what if we also want to\nhandle a response of the call?"),(0,r.kt)("p",null,"In CosmWasm, handling the outcome is straightforward: you generally handle successful execution or errors through the\nexecution result."),(0,r.kt)("p",null,"Let's modify the code a bit, so we would be able to call a minimal a contract and handle response of the call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::{\n    entry_point, from_json, to_json_binary, Addr, Binary, CosmosMsg, DecimalRangeExceeded, Deps,\n    DepsMut, Env, MessageInfo, OverflowError, Reply, Response, StdError, StdResult, SubMsg,\n    Uint128, WasmMsg,\n};\n\npub fn send_message_to_contract(deps: DepsMut, amount: Uint128) -> Result<Response, ContractError> {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Here we define a message to a minimal contract instance to increase the counter by the specified amount\n    let message = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.clone().minimal_contract_address.into_string(),\n        msg: to_json_binary(&MinimalContractExecuteMsg::IncreaseCount { amount })?,\n        funds: vec![], // Optionally, you can send funds along with the message.\n    });\n\n    let current_counter_value: CurrentValueResponse = deps.querier.query_wasm_smart(\n        config.minimal_contract_address,\n        &MinimalContractQueryMsg::CurrentValue {},\n    )?;\n\n    // we create a submessage to catch the successfull response\n    Ok(Response::new()\n        .add_submessage(\n            // Add counter to submsg payload, so we could parse it in the reply handler.\n            // Note that you can also use reply_on_error, as well as reply_always.\n            SubMsg::reply_on_success(message, INCREASE_COUNT_REPLY_ID)\n                .with_payload(to_json_binary(&current_counter_value.current_value)?),\n        )\n        .add_attribute("action", "send_message_to_contract"))\n}\n\n/// ----------------------------- REPLY HANDLER ------------------------------------\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> StdResult<Response> {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Handle the response message here\n    if msg.id == INCREASE_COUNT_REPLY_ID {\n        // parse data field from the minimal contract execution response to get the counter value\n        let previous_counter: Uint128 = from_json(&msg.payload)?;\n\n        // make a query to a minimal contract to get current counter value\n        let current_counter_value_via_query: CurrentValueResponse = deps.querier.query_wasm_smart(\n            config.minimal_contract_address,\n            &MinimalContractQueryMsg::CurrentValue {},\n        )?;\n\n        // Check whether the counter value was not actually updated by checking the previous counter \n        // value we sent in SubMsg and current counter value from a query\n        if current_counter_value_via_query.current_value <= previous_counter {\n            return Err(StdError::generic_err(\n                "counter from SubMsg does not equal to a counter from query",\n            ));\n        }\n\n        Ok(Response::new()\n            .add_attribute("reply", "success")\n            .add_attribute("new_counter", current_counter_value_via_query.current_value))\n    } else {\n        Err(StdError::generic_err("unknown reply id"))\n    }\n}\n')),(0,r.kt)("p",null,"In this example, ",(0,r.kt)("inlineCode",{parentName:"p"},"SubMsg")," is used to capture and handle responses by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"reply_on")," attribute. You can also set\nit to ",(0,r.kt)("inlineCode",{parentName:"p"},"reply_on_error")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"reply_always")," depending on the case. In the reply handler, we process the message response\nbased on the ID ",(0,r.kt)("inlineCode",{parentName:"p"},"INCREASE_COUNT_REPLY_ID"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"First, we check the reply message ID. If it's not ",(0,r.kt)("inlineCode",{parentName:"li"},"INCREASE_COUNT_REPLY_ID"),", something went wrong, so we return an\nerror."),(0,r.kt)("li",{parentName:"ol"},"Next, we decode the ",(0,r.kt)("inlineCode",{parentName:"li"},"payload")," field of the message to extract the ",(0,r.kt)("inlineCode",{parentName:"li"},"previous_counter")," value, which\nwe ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/onboarding/blob/cf20ed2a2258e772e86f12421507617a143aa675/contracts/calling_modules_and_contracts/src/contract.rs#L139"},"set in our contract through the execute message"),"."),(0,r.kt)("li",{parentName:"ol"},"Then, we perform\na ",(0,r.kt)("inlineCode",{parentName:"li"},"CurrentValue")," ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/neutron-org/onboarding/blob/f438ffae9e1e7d949534f36644f38b457c499e67/minimal_contract/src/contract.rs#L149"},"query to our Minimal contract"),"\nto get the current counter value from the contract."),(0,r.kt)("li",{parentName:"ol"},"Finally, we compare these values to ensure everything worked as expected. Simple, right?")),(0,r.kt)("admonition",{title:"Note",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can see the whole\ncontract ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/f438ffae9e1e7d949534f36644f38b457c499e67/calling_modules_and_contracts/src/contract.rs#L120"},"here."))),(0,r.kt)("h2",{id:"modules"},"Modules"),(0,r.kt)("p",null,"With modules, the interaction interface is slightly different, but semantically the same 3 things need to be covered:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Sending messages to modules,"),(0,r.kt)("li",{parentName:"ol"},"Processing responses to those messages,"),(0,r.kt)("li",{parentName:"ol"},"Querying data from modules.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Historical background:")," Stargate and gRPC"),(0,r.kt)("p",null,(0,r.kt)("p",null,"Historically, some modules had their own WASM bindings implemented by developers to handle messages and queries from\nsmart contracts. For modules without these bindings, Stargate was used to achieve similar functionality. Stargate\nprimarily relied on gRPC for sending and receiving messages, but its interface was inconsistent, returning\nprotobuf-encoded messages for some queries and JSON-encoded ones for others\u2014causing significant frustration for\ndevelopers. Now that Stargate is outdated, on Neutron, you only need to work with gRPC and protobuf-encoded messages to\ninteract with core modules."))),(0,r.kt)("h3",{id:"sending-messages-to-cosmos-sdk-modules"},"Sending Messages to Cosmos SDK Modules"),(0,r.kt)("p",null,"In this tutorial, we\u2019ll explore how a CosmWasm contract interacts with Cosmos SDK modules using custom messages. We\u2019ll\nwalk through sending messages to Cosmos SDK modules, handling responses, and querying data. The provided code will guide\nus through sending tokens (after converting an amount in USD to NTRN using an oracle), handling the response when the\ntokens are sent, and querying additional data."),(0,r.kt)("admonition",{title:"Note",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can see the whole contract ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/f438ffae9e1e7d949534f36644f38b457c499e67/calling_modules_and_contracts/src/contract.rs#L135"},"here."))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"send_tokens")," function demonstrates how to send tokens by communicating with two Cosmos SDK modules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Oracle Module (to get the NTRN price)"),(0,r.kt)("li",{parentName:"ul"},"Bank Module (to send tokens)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::{\n    entry_point, from_json, to_json_binary, Addr, Binary, CosmosMsg, DecimalRangeExceeded, Deps,\n    DepsMut, Env, MessageInfo, OverflowError, Reply, Response, StdError, StdResult, SubMsg,\n    Uint128, WasmMsg,\n};\n\nuse minimal_contract::contract::CurrentValueResponse;\nuse minimal_contract::contract::ExecuteMsg as MinimalContractExecuteMsg;\nuse minimal_contract::contract::QueryMsg as MinimalContractQueryMsg;\n\nuse neutron_std::types::cosmos::bank::v1beta1::MsgSend;\nuse neutron_std::types::cosmos::base::v1beta1::Coin as SDKCoin;\n\nuse neutron_std::types::slinky::{self, oracle};\n\npub fn send_tokens(\n    deps: DepsMut,\n    env: Env,\n    to_address: String,\n    usd_amount: Uint128,\n) -> Result<Response, ContractError> {\n    // get NTRN price from Slinky\n    let slinky_querier = oracle::v1::OracleQuerier::new(&deps.querier);\n    let ntrn_price = slinky_querier.get_price(Some(slinky::types::v1::CurrencyPair {\n        base: "NTRN".to_string(),\n        quote: "USD".to_string(),\n    }))?;\n\n    if ntrn_price.price.is_none() {\n        return Err(ContractError::Std(StdError::generic_err(\n            "no price for NTRN/USD pair",\n        )));\n    }\n\n    // normalize the price\n    let normalized_price = Decimal::from_atomics(\n        Uint128::from_str(&ntrn_price.price.unwrap().price)?,\n        ntrn_price.decimals as u32,\n    )?;\n\n    // convert usd amount to ntrn amount\n    let ntrn_amount = Decimal::from_str(&usd_amount.to_string())?\n        .checked_mul(normalized_price)?\n        .to_uint_floor();\n\n    // compose bank send message\n    let msg = MsgSend {\n        from_address: env.contract.address.into_string(),\n        to_address,\n        amount: vec![SDKCoin {\n            denom: "untrn".to_string(),\n            amount: ntrn_amount.to_string(),\n        }],\n    };\n\n    let sub_msg = SubMsg::reply_on_success(Into::<CosmosMsg>::into(msg), BANK_SEND_REPLY_ID); // ReplyOn::Success will capture the response only if send message succeeded.\n\n    Ok(Response::new()\n        .add_submessage(sub_msg)\n        .add_attribute("action", "send_tokens"))\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 1"),": Querying the Oracle Module for the Price of NTRN"),(0,r.kt)("p",null,"Before sending tokens, we need to convert the USD amount into NTRN. To achieve this, the contract queries the Oracle\nModule for the current NTRN/USD price:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let slinky_querier = oracle::v1::OracleQuerier::new(&deps.querier);\nlet ntrn_price = slinky_querier.get_price(Some(slinky::types::v1::CurrencyPair {\n    base: "NTRN".to_string(),\n    quote: "USD".to_string(),\n}))?;\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Oracle Module Interaction:")," This code uses the ",(0,r.kt)("inlineCode",{parentName:"li"},"oracle::v1::OracleQuerier")," to create a querier and request the price\nfor the ",(0,r.kt)("inlineCode",{parentName:"li"},"NTRN/USD")," currency pair from the Slinky oracle module. It uses the get_price method to fetch the current\nprice."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Error Handling:")," If the oracle doesn\u2019t return a price (",(0,r.kt)("inlineCode",{parentName:"li"},"ntrn_price.price.is_none()"),"), the contract returns an error,\nensuring that no transaction occurs with invalid pricing data.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2"),": Normalizing the Price and Converting USD to NTRN"),(0,r.kt)("p",null,"Once the price is retrieved, we need to normalize the result and convert the ",(0,r.kt)("inlineCode",{parentName:"p"},"USD")," amount into ",(0,r.kt)("inlineCode",{parentName:"p"},"NTRN")," tokens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let normalized_price = Decimal::from_atomics(\n    Uint128::from_str(&ntrn_price.price.unwrap().price)?,\n    ntrn_price.decimals as u32,\n)?;\n// convert usd amount to ntrn amount\nlet ntrn_amount = Decimal::from_str(&usd_amount.to_string())?\n    .checked_div(normalized_price)?\n    .to_uint_floor();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The retrieved price is normalized to convert it into a usable format by accounting for the number of decimal places."),(0,r.kt)("li",{parentName:"ul"},"The contract multiplies the USD amount by the normalized ",(0,r.kt)("inlineCode",{parentName:"li"},"NTRN")," price to determine how many ",(0,r.kt)("inlineCode",{parentName:"li"},"NTRN")," tokens to send.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3"),": Sending Tokens to a Recipient Using the Bank Module"),(0,r.kt)("p",null,"Once the token amount is calculated, the contract sends the ",(0,r.kt)("inlineCode",{parentName:"p"},"NTRN")," tokens to the recipient by constructing a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgSend"),"\nmessage. This message is sent to the Bank Module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let msg = MsgSend {\n    from_address: env.contract.address.into_string(),\n    to_address,\n    amount: vec![SDKCoin {\n        denom: "untrn".to_string(),\n        amount: ntrn_amount.to_string(),\n    }],\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Bank Module Interaction: The contract creates a ",(0,r.kt)("inlineCode",{parentName:"li"},"MsgSend")," message, which sends the calculated ",(0,r.kt)("inlineCode",{parentName:"li"},"NTRN")," tokens from the\ncontract\u2019s address (",(0,r.kt)("inlineCode",{parentName:"li"},"env.contract.address"),") to the recipient\u2019s address (",(0,r.kt)("inlineCode",{parentName:"li"},"to_address"),")."),(0,r.kt)("li",{parentName:"ul"},"The amount is specified using the micro-denomination ",(0,r.kt)("inlineCode",{parentName:"li"},"untrn"),";")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 4"),": Handling Success with SubMsg"),(0,r.kt)("p",null,"To handle the response from the Bank Module, the message is wrapped in a SubMsg:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let sub_msg = SubMsg::reply_on_success(Into::<CosmosMsg>::into(msg), BANK_SEND_REPLY_ID);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"SubMsg::reply_on_success")," function ensures that the contract will capture the response when the token transfer\nsucceeds. The ",(0,r.kt)("inlineCode",{parentName:"li"},"BANK_SEND_REPLY_ID")," helps identify this message\u2019s reply when processing the result later.")),(0,r.kt)("p",null,"The function returns a Response object that contains the submessage and logs the action (",(0,r.kt)("inlineCode",{parentName:"p"},"send_tokens"),")."),(0,r.kt)("h2",{id:"interacting-with-the-contract"},"Interacting with the contract"),(0,r.kt)("h3",{id:"compile-the-contract-binary"},"Compile the contract binary"),(0,r.kt)("p",null,"Go to the ",(0,r.kt)("inlineCode",{parentName:"p"},"calling_modules_and_contracts")," project directory in the ",(0,r.kt)("inlineCode",{parentName:"p"},"onboarding")," repository:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd onboarding/calling_modules_and_contracts\n")),(0,r.kt)("p",null,"Then build the contract binary:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'docker run --rm -v "$(pwd)":/code \\\n  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  --platform linux/amd64 \\\n  cosmwasm/optimizer:0.16.0\ncd ..\n')),(0,r.kt)("p",null,"You will find the compiled binary in ",(0,r.kt)("inlineCode",{parentName:"p"},"calling_modules_and_contracts/artifacts/calling_modules_and_contracts.wasm"),"."),(0,r.kt)("h3",{id:"upload-the-contract"},"Upload the contract"),(0,r.kt)("p",null,"Now, you need to upload the contract binary (copy the ",(0,r.kt)("inlineCode",{parentName:"p"},"txhash")," value from the last line of the command output!):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"neutrond tx wasm store calling_modules_and_contracts/artifacts/calling_modules_and_contracts.wasm \\\n --node tcp://0.0.0.0:26657 --chain-id ntrntest --gas 3000000 \\\n --fees 100000untrn --from demowallet1\n")),(0,r.kt)("p",null,"Next, you need to get the ",(0,r.kt)("inlineCode",{parentName:"p"},"code_id")," of the binary that you just uploaded:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q tx 855C2F0D3E120D986B65EB250BBB3C24ED38F7251E928F03DB96AF8186C00973 --output json \\\n  --node tcp://0.0.0.0:26657 | jq ".events[8]"  \n{\n  "type": "store_code",\n  "attributes": [\n    {\n      "key": "code_checksum",\n      "value": "5aca867b2af7295c7ff224dd62605a8f1601ccee73161ed41e4c43034327f021",\n      "index": true\n    },\n    {\n      "key": "code_id",\n      "value": "21",\n      "index": true\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"You can see in the output above that the ",(0,r.kt)("inlineCode",{parentName:"p"},"code_id")," of our contract binary is ",(0,r.kt)("inlineCode",{parentName:"p"},"21"),". Now that we know it, we can finally\ninstantiate our contract (once again, copy the ",(0,r.kt)("inlineCode",{parentName:"p"},"txhash")," value):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond tx wasm instantiate 21 \'{"minimal_contract_address": "neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj"}\' --label minimal_contract \\\n  --no-admin --node tcp://0.0.0.0:26657 --from demowallet1 --chain-id ntrntest \\\n  --gas 1500000 --fees 4000untrn\n')),(0,r.kt)("p",null,"Lets have a look at the transaction arguments and flags once again:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"21"),": the ",(0,r.kt)("inlineCode",{parentName:"li"},"code_id")," that we got after uploading our compiled binary. As we mentioned previously, you can instantiate\nmultiple identical contracts from one ",(0,r.kt)("inlineCode",{parentName:"li"},"code_id"),"!"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'\'{"minimal_contract_address": "neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj"}\''),": that's\nour ",(0,r.kt)("inlineCode",{parentName:"li"},"InstantiateMsg")," that we defined in our contract. If we provided a JSON that\ncould not be parsed into ",(0,r.kt)("inlineCode",{parentName:"li"},"InstantiateMsg"),", we would receive an error.")),(0,r.kt)("p",null,"Now, we need to query the transaction details to get the address of the instantiated contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q tx B45E9D20A5744A81C2C3B0E75D0E740E56E0E0FD20206DDFC77F6FCFE11333B8 --output json --node tcp://0.0.0.0:26657 | jq ".events[8]"\n{\n  "type": "instantiate",\n  "attributes": [\n    {\n      "key": "_contract_address",\n      "value": "neutron1jarq7kgdyd7dcfu2ezeqvg4w4hqdt3m5lv364d8mztnp9pzmwwwqjw7fvg",\n      "index": true\n    },\n    {\n      "key": "code_id",\n      "value": "20",\n      "index": true\n    }\n  ]\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Congratulations!")," The contract is now instantiated, and is ready to process our messages."),(0,r.kt)("admonition",{title:"Contract addresses",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"The address of your contract might be different from what you see in this tutorial. Make sure that you are replacing\nthe addresses from the commands below with the address of ",(0,r.kt)("strong",{parentName:"p"},"your")," contract!")),(0,r.kt)("h3",{id:"interact-with-the-contract"},"Interact with the contract"),(0,r.kt)("p",null,"Now that the contract is instantiated and we know its address, so we can interact with it."),(0,r.kt)("p",null,"As you remember, the purpose of our contract is to do two things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"call the Minimal Contract to increase it's counter;"),(0,r.kt)("li",{parentName:"ul"},"send some amount of NTRN tokens to some address.")),(0,r.kt)("p",null,"Let's see how to do each thing:"),(0,r.kt)("h5",{id:"increase-counter-in-the-minimal-contract"},"Increase counter in the Minimal Contract"),(0,r.kt)("p",null,"At first, let's see the counter of the Minimal Contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q wasm contract-state smart neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj \\\n  \'{"current_value": {}}\' --output json --node tcp://0.0.0.0:26657\n{"data":{"current_value":"43"}}\n')),(0,r.kt)("p",null,"Let's now increase the value by ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," by sending an ",(0,r.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," message to ",(0,r.kt)("strong",{parentName:"p"},"our contract"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond tx wasm execute neutron1jarq7kgdyd7dcfu2ezeqvg4w4hqdt3m5lv364d8mztnp9pzmwwwqjw7fvg \\\n  \'{"increase_count": {"amount": "1"}}\' --node tcp://0.0.0.0:26657 --from demowallet1 \\\n  --chain-id ntrntest --gas 1500000 --fees 4000untrn\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"neutron1jarq7kgdyd7dcfu2ezeqvg4w4hqdt3m5lv364d8mztnp9pzmwwwqjw7fvg"),": the address of our instantiated contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'\'{"increase_count": {"amount": "1"}}\''),": the JSON representation of the ",(0,r.kt)("inlineCode",{parentName:"li"},"ExecuteMsg::IncreaseCount")," message that we\ndefined in our contract.")),(0,r.kt)("p",null,"If we query the Minimal contract once again, we'll see that the current value was increased by 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q wasm contract-state smart neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj \\\n  \'{"current_value": {}}\' --output json --node tcp://0.0.0.0:26657\n{"data":{"current_value":"44"}}\n')),(0,r.kt)("p",null,"So our contract did his job successfully!"),(0,r.kt)("h5",{id:"send-ntrns-to-some-address"},"Send NTRNs to some address"),(0,r.kt)("p",null,"First of all, let's top up our contract with some NTRNs, since it must have something on its address to be able to send\ntokens to other addresses:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"neutrond tx bank send $(neutrond keys show demowallet1 -a) neutron1jarq7kgdyd7dcfu2ezeqvg4w4hqdt3m5lv364d8mztnp9pzmwwwqjw7fvg 100000000untrn --node tcp://0.0.0.0:26657 --from demowallet1 \\\n  --chain-id ntrntest --gas 1500000 --fees 4000untrn\n")),(0,r.kt)("p",null,"The purpose of our ",(0,r.kt)("inlineCode",{parentName:"p"},"send_tokens")," handler, is to accept a number of tokens in USD (",(0,r.kt)("inlineCode",{parentName:"p"},"usd_amount"),"), query a price of NTRN\ntoken in USD via Slinky, calculated how many NTRNs\nthe contract must send according to the price to some address (",(0,r.kt)("inlineCode",{parentName:"p"},"to_address"),")."),(0,r.kt)("p",null,"Let's see NTRN price in USD via Slinky:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'$ curl -X \'GET\' \\\n  \'http://0.0.0.0:1317/slinky/oracle/v1/get_price?currency_pair.Base=NTRN&currency_pair.Quote=USD\' \\\n  -H \'accept: application/json\' | jq\n\n{\n  "price": {\n    "price": "40545945",\n    "block_timestamp": "2024-10-16T13:51:50.926109199Z",\n    "block_height": "15723526"\n  },\n  "nonce": "3411738",\n  "decimals": "8",\n  "id": "43"\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: you can check a full Slinky's documentation ",(0,r.kt)("a",{parentName:"p",href:"https://docs.skip.build/connect/developers/high-level"},"here"))),(0,r.kt)("p",null,"The response has a lot of fields, but we interested only in a couple of them:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"decimals")," - decimals represents the number of decimals that the quote-price is represented in. It is used to scale\nthe ",(0,r.kt)("inlineCode",{parentName:"li"},".price.price")," to its proper value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"price.price")," - represents the quote-price for a token. In our case (taking the ",(0,r.kt)("inlineCode",{parentName:"li"},"decimals")," field into account), NTRN\nequals to ",(0,r.kt)("inlineCode",{parentName:"li"},"40545945 / 10^8 = ~0.4 USD"),".")),(0,r.kt)("p",null,"That means, if we call our contract's handler with ",(0,r.kt)("inlineCode",{parentName:"p"},"usd_amount = 10"),", it'll send 25 NTRNs,\ncause ",(0,r.kt)("inlineCode",{parentName:"p"},"10 USD * ~0.4 = ~25 NTRN"),"."),(0,r.kt)("p",null,"Let's check it out!"),(0,r.kt)("p",null,"Let's try to send it to our Minimal Contract instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond tx wasm execute neutron1jarq7kgdyd7dcfu2ezeqvg4w4hqdt3m5lv364d8mztnp9pzmwwwqjw7fvg  \'{"send_ntrn": {"to_address":"neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj", "usd_amount": "1000000"}}\' --node tcp://0.0.0.0:26657 --from demowallet1 \\\n  --chain-id ntrntest --gas 1500000 --fees 4000untrn\n')),(0,r.kt)("p",null,"And now let's check balance of the Minimal contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q bank balances neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj --node tcp://0.0.0.0:26657\n\nbalances:\n- amount: "2500000"\n  denom: untrn\npagination:\n  next_key: null\n  total: "0"\n')),(0,r.kt)("p",null,"This is exactly what we expected!"))}m.isMDXComponent=!0}}]);