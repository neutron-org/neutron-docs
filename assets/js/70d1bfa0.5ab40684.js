"use strict";(self.webpackChunkneutron=self.webpackChunkneutron||[]).push([[61865],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=o,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},68542:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const r={},i="Part 1: Minimal Application",s={unversionedId:"tutorials/onboarding/part-1-minimal-application",id:"tutorials/onboarding/part-1-minimal-application",title:"Part 1: Minimal Application",description:"Overview",source:"@site/docs/tutorials/onboarding/part-1-minimal-application.md",sourceDirName:"tutorials/onboarding",slug:"/tutorials/onboarding/part-1-minimal-application",permalink:"/tutorials/onboarding/part-1-minimal-application",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"CosmWasm + ICQ",permalink:"/tutorials/cosmwasm_icq"},next:{title:"Part 2: Calling Modules and Contracts",permalink:"/tutorials/onboarding/part-2-calling-modules-and-contracts"}},l={},u=[{value:"Overview",id:"overview",level:2},{value:"What are Neutron smart contracts?",id:"what-are-neutron-smart-contracts",level:2},{value:"What does a Neutron smart contract look like?",id:"what-does-a-neutron-smart-contract-look-like",level:2},{value:"How do I write a smart contract for Neutron?",id:"how-do-i-write-a-smart-contract-for-neutron",level:2},{value:"Storage: how to I store data?",id:"storage-how-to-i-store-data",level:3},{value:"Instantiation: how do I initialise a contract?",id:"instantiation-how-do-i-initialise-a-contract",level:3},{value:"InstantiateMsg",id:"instantiatemsg",level:4},{value:"<code>instantiate()</code> entrypoint",id:"instantiate-entrypoint",level:4},{value:"Processing messages: how do I make a contract do something?",id:"processing-messages-how-do-i-make-a-contract-do-something",level:3},{value:"<code>ExecuteMsg</code>: defining the set of possible actions",id:"executemsg-defining-the-set-of-possible-actions",level:4},{value:"<code>execute()</code> entrypoint: defining handlers for messages",id:"execute-entrypoint-defining-handlers-for-messages",level:4},{value:"Querying data: how do I... query data?",id:"querying-data-how-do-i-query-data",level:3},{value:"How to deploy and execute?",id:"how-to-deploy-and-execute",level:2},{value:"Prepare the environment",id:"prepare-the-environment",level:3},{value:"Run the localnet",id:"run-the-localnet",level:3},{value:"Compile the contract binary",id:"compile-the-contract-binary",level:3},{value:"Upload the contract",id:"upload-the-contract",level:3},{value:"Interact with the contract",id:"interact-with-the-contract",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"part-1-minimal-application"},"Part 1: Minimal Application"),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Everyone knows how to write smart contracts for Ethereum. Some people even know how to write smart contracts for Solana.\nBut the knowledge of how to write smart contracts for Cosmos SDK chains is sacred, shared by the few, and hard to\nobtain."),(0,o.kt)("p",null,"This CosmWasm onboarding tutorial has one goal: to show the reader that building applications with CosmWasm is not\nscary."),(0,o.kt)("p",null,"In ",(0,o.kt)("strong",{parentName:"p"},"Part 1")," of this tutorial you will learn how to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a simple, yet functional smart contract using CosmWasm."),(0,o.kt)("li",{parentName:"ol"},"Deploy your web3 application locally and on the Neutron testnet.")),(0,o.kt)("h2",{id:"what-are-neutron-smart-contracts"},"What are Neutron smart contracts?"),(0,o.kt)("p",null,"We assume you might not know ",(0,o.kt)("strong",{parentName:"p"},"anything")," about Neutron, so let's start with a basic overview. If you're already\nfamiliar with Cosmos chains, you can skip this section. We've tucked the details into collapsible sections to make it\nless scary."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"Important information:")," modules and messages"),(0,o.kt)("p",null,(0,o.kt)("p",null,"Neutron is a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk"},"Cosmos SDK")," chain, which means that it's a collection of ",(0,o.kt)("strong",{parentName:"p"},"modules"),"\n(",(0,o.kt)("inlineCode",{parentName:"p"},"bank"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"dex"),", etc.) running on top of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft"},"CometBFT")," consensus. Each module\ndefines a set of ",(0,o.kt)("strong",{parentName:"p"},"messages")," that it can process. A single ",(0,o.kt)("strong",{parentName:"p"},"transaction")," can include multiple messages to more than\none module."),(0,o.kt)("p",null,"To ",(0,o.kt)("strong",{parentName:"p"},"interact with Neutron"),", you need to ",(0,o.kt)("strong",{parentName:"p"},"send messages")," to Neutron modules. For example, if you want to send\nsome ",(0,o.kt)("inlineCode",{parentName:"p"},"untrn")," to your friend, you will need to execute a transaction containing\nan ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgSend")," message to the ",(0,o.kt)("inlineCode",{parentName:"p"},"bank")," module. This message might look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@type": "/cosmos.bank.v1beta1.MsgSend",\n  "from_address": "neutron1cvsh2c2vasktkh7krt2w2dhyt0njs0adh5ewqv",\n  "to_address": "neutron1vqwe5hda0sjn0tyhd2w2trk7hktksav2c2hsvc",\n  "amount": [\n    {\n      "denom": "untrn",\n      "amount": "42"\n    }\n  ]\n}\n')),(0,o.kt)("p",null,"As a user, usually you don't have to deal with raw messages yourself \u2014 it's done for you either by the CLI or by a UI.\nYou'll examples of using the CLI later on in this document."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"Important information:")," smart contracts"),(0,o.kt)("p",null,(0,o.kt)("p",null,"Smart contracts are enabled on Neutron by a module called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd"},"wasmd"),". As any other\nmodule, ",(0,o.kt)("inlineCode",{parentName:"p"},"wasmd")," defines a set of messages that it can process, e.g.: ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgStoreCode")," (used to upload compiled contract\nbinaries), ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," (used to execute existing contracts), etc."),(0,o.kt)("p",null,"For now, the main thing that you need to know about the ",(0,o.kt)("inlineCode",{parentName:"p"},"wasmd")," messages is that ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," includes an\n",(0,o.kt)("strong",{parentName:"p"},"embedded message for a smart contract"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@type": "/cosmwasm.wasm.v1.MsgExecuteContract",\n  "sender": "neutron1cvsh2c2vasktkh7krt2w2dhyt0njs0adh5ewqv",\n  "contract": "neutron1a5xz4zm0gkpcf92ddm7fw8pghg2mf4wm6cyu6cgcruq35upf7auslnnfye",\n  "msg": {\n    "increase_count": {\n      "amount": "42"\n    }\n  },\n  "funds": []\n}\n')),(0,o.kt)("p",null,"That's because ",(0,o.kt)("strong",{parentName:"p"},"smart contract developers can define the messages that the contract is able to process.")),(0,o.kt)("p",null,"In the snippet above, the message under the ",(0,o.kt)("inlineCode",{parentName:"p"},'"msg"')," key is a message to a smart contract identified by the ",(0,o.kt)("inlineCode",{parentName:"p"},'"contract"'),"\naddress. If you include the message above in a transaction, the following sequence of events will happen:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Neutron will identify that the incoming message needs to be sent to the ",(0,o.kt)("inlineCode",{parentName:"li"},"wasmd")," module."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"wasmd")," module will look up the contract binary by its address and load it."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"wasmd")," module will take message under the ",(0,o.kt)("inlineCode",{parentName:"li"},'"msg""')," key and will pass it to the ",(0,o.kt)("inlineCode",{parentName:"li"},"execute()")," entrypoint of\nthe contract."),(0,o.kt)("li",{parentName:"ol"},"The contract will try to parse the incoming data into the ",(0,o.kt)("inlineCode",{parentName:"li"},'"increase_count"')," message that is defined on the contract\nlevel, and will execute the handler associated with it.")))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"Important information:")," contract lifecycle, contract entry points"),(0,o.kt)("p",null,(0,o.kt)("p",null,"The creation of a contract involves ",(0,o.kt)("strong",{parentName:"p"},"three steps"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"First you need to ",(0,o.kt)("strong",{parentName:"li"},"compile")," the contract binary (more on that in the ",(0,o.kt)("strong",{parentName:"li"},"How to upload a contract and interact with\nit?")," section)."),(0,o.kt)("li",{parentName:"ol"},"Then you need to ",(0,o.kt)("strong",{parentName:"li"},"upload")," the contract binary to the chain by sending an ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgStoreCode")," to the ",(0,o.kt)("inlineCode",{parentName:"li"},"wasmd")," module,\nwhich makes Neutron save the binary under a unique ",(0,o.kt)("inlineCode",{parentName:"li"},"code_id"),"."),(0,o.kt)("li",{parentName:"ol"},"Lastly, you need to ",(0,o.kt)("strong",{parentName:"li"},"instantiate")," a contract from this ",(0,o.kt)("inlineCode",{parentName:"li"},"code_id")," by sending an ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgInstantiateContract")," to\nthe ",(0,o.kt)("inlineCode",{parentName:"li"},"wasmd")," module, which will pass the instantiation message to the contract's ",(0,o.kt)("inlineCode",{parentName:"li"},"instantiate()")," entrypoint and create\nan actual contract address that you can interact with.")),(0,o.kt)("p",null,"After a contract was instantiated, you can start to send messages to it using the ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"wasmd"),"\nmodule. Multiple contracts can be created from the same ",(0,o.kt)("inlineCode",{parentName:"p"},"code_id")," without the need to re-upload the binary, and each\ninstance with have a unique address."),(0,o.kt)("p",null,"There are ",(0,o.kt)("strong",{parentName:"p"},"3 main contract entry points")," that you need to know about that are used by the ",(0,o.kt)("inlineCode",{parentName:"p"},"wasmd")," module to interact\nwith a contract: ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"query()"),". We are going to implement all of them in this part of our\ntutorial."))),(0,o.kt)("h2",{id:"what-does-a-neutron-smart-contract-look-like"},"What does a Neutron smart contract look like?"),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"really")," minimal smart contract would be about 10 lines long, and would be useless for our purposes. Our smart\ncontract\nis going to be a contract that ",(0,o.kt)("strong",{parentName:"p"},"actually does")," something:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Keeps a ",(0,o.kt)("inlineCode",{parentName:"li"},"Uint128")," value in the storage."),(0,o.kt)("li",{parentName:"ol"},"Allows anyone to increase this value by some amount, if the increase amount is less than ",(0,o.kt)("inlineCode",{parentName:"li"},"100"),"."),(0,o.kt)("li",{parentName:"ol"},"Allows anyone to query the current value from the storage.")),(0,o.kt)("p",null,"Fun, right? Right. ",(0,o.kt)("strong",{parentName:"p"},"Check out the full source code")," of this contract\non ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/main/minimal_contract/src/contract.rs"},"GitHub"),". Take a look if you\nenjoy diving into raw source code \u2013 we\u2019ve included ",(0,o.kt)("strong",{parentName:"p"},"lots")," of comments. But don\u2019t worry, we'll walk you through every\npart of it, step by step, below."),(0,o.kt)("p",null,"After having a look at the source code, you might have some questions right away, and we will try to address them\nimmediately:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},'"How is this minimal? It\'s 160 lines of code!"')," Yes, but 50% of them are comments!"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},'"Wait, is this Rust?"')," Yes, it's in Rust. Rust is scary, but writing CosmWasm smart contracts is probably the\neasiest\nthing you can do with Rust, because everything is single-threaded.")),(0,o.kt)("admonition",{title:"The Choice",type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"With these initial questions out of the way, ",(0,o.kt)("strong",{parentName:"p"},"you now have a choice"),":"),(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},"You can proceed directly to the ",(0,o.kt)("strong",{parentName:"li"},"How to deploy and execute?")," section at the end of this document to learn how to\nuse CLI to run a Neutron localnet, deploy our example contract and interact with it,"),(0,o.kt)("li",{parentName:"ol"},"Or you can read the ",(0,o.kt)("strong",{parentName:"li"},"How do I write a smart contract for Neutron?")," section first if you want to understand the\ninner workings of our example contract."))),(0,o.kt)("h2",{id:"how-do-i-write-a-smart-contract-for-neutron"},"How do I write a smart contract for Neutron?"),(0,o.kt)("h3",{id:"storage-how-to-i-store-data"},"Storage: how to I store data?"),(0,o.kt)("admonition",{title:"TL;DR",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"cw_storage_plus::Item")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"cw_storage_plus::Map")," types to store standard and custom types."),(0,o.kt)("p",{parentName:"admonition"},"See it in context: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/main/minimal_contract/src/contract.rs#L17"},"link"))),(0,o.kt)("p",null,"Storing data is essential, that's why we start with it. Almost any useful contract manages some storage. In CosmWasm, in\norder to have storage, you need to initialise it using a type from the ",(0,o.kt)("inlineCode",{parentName:"p"},"cw_storage_plus")," package. In our case, it's\n",(0,o.kt)("inlineCode",{parentName:"p"},"Item<Uint128>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use cw_storage_plus::Item;\n\npub const COUNTER: Item<Uint128> = Item::new("counter");\n')),(0,o.kt)("p",null,"This will make CosmWasm allocate some space in the persistent storage for a single ",(0,o.kt)("inlineCode",{parentName:"p"},"Uint128")," value under the\n",(0,o.kt)("inlineCode",{parentName:"p"},'"counter"')," key. As a smart contract developer, you don't care about this key at all, but you must make sure that\neach storage item has a unique key."),(0,o.kt)("p",null,"Saving single integers is kind of lame, but don't worry: ",(0,o.kt)("strong",{parentName:"p"},"you can save almost anything to storage"),". For example, ",(0,o.kt)("strong",{parentName:"p"},"you\ncan save vectors"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"Item<Vec<Uint128>>"),"."),(0,o.kt)("p",null,"Or ",(0,o.kt)("strong",{parentName:"p"},"you can save the types that you created yourself")," (just make sure you added the fancy derive macro to the type\ndeclaration):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Config {\n    pub important_parameter: String,\n}\n\npub const CONFIG: Item<Config> = Item::new("config");\n')),(0,o.kt)("p",null,"For maps, ",(0,o.kt)("inlineCode",{parentName:"p"},"cw_storage_plus")," has a special ",(0,o.kt)("inlineCode",{parentName:"p"},"Map")," type, in which you can also map pretty much anything to anything, if it\nserialises properly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub const EXAMPLE_MAP: Map<Uint128, Uint128> = Map::new("example-map");\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"More storage types:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"cw_storage_plus")," has even more storage types, some of which allow you to track the height at\nwhich a certain value was saved to your storage item.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"A note on project layout:")," usually all storage items and storage types are defined in a separate\nfile (",(0,o.kt)("inlineCode",{parentName:"p"},"src/state.rs"),"), alongside the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/contract.rs")," file. Here we define everything in one place for the sake of\nsimplicity.")),(0,o.kt)("h3",{id:"instantiation-how-do-i-initialise-a-contract"},"Instantiation: how do I initialise a contract?"),(0,o.kt)("admonition",{title:"TL;DR",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()")," entrypoint and the ",(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," message to have custom instantiation logic for your\ncontract."),(0,o.kt)("p",{parentName:"admonition"},"See it in context: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/main/minimal_contract/src/contract.rs#L19-L64"},"link"))),(0,o.kt)("h4",{id:"instantiatemsg"},"InstantiateMsg"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct InstantiateMsg {\n    initial_value: Uint128,\n}\n")),(0,o.kt)("p",null,"In the snippet above, 2 things happen: the definition of ",(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),", and the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()"),"\nentry point."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," can carry any information we might find useful while populating our new contract. In our\ncase, we decided to use ",(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," to set the initial value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"COUNTER")," storage item that was initialised in\nthe previous section."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," You need to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"#[derive(Serialize, <...> JsonSchema)]")," derive macro to the definitions of your custom\ntypes (so that they can be properly serialised by Rust).")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," A common practice in the CosmWasm world is to define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," type, create a storage item for it and then\nto set the initial values for ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," parameters in the ",(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),".")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"A note on project layout:")," usually all messages are defined in a separate file (",(0,o.kt)("inlineCode",{parentName:"p"},"src/state.rs"),"), alongside\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"src/contract.rs")," file. Here we define everything in one place for the sake of simplicity.")),(0,o.kt)("h4",{id:"instantiate-entrypoint"},(0,o.kt)("inlineCode",{parentName:"h4"},"instantiate()")," entrypoint"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response<NeutronMsg>, ContractError> {\n    COUNTER.save(deps.storage, &msg.initial_value)?;\n\n    Ok(Response::new()\n        .add_attribute("action", "instantiate")\n        .add_attribute("initial_value", msg.initial_value)\n        .add_attribute("contract_address", env.contract.address)\n        .add_attribute("sender", info.sender.to_string()))\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()")," entry point expects the following arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"deps"),": most importantly, gives you access to the ",(0,o.kt)("em",{parentName:"li"},"storage")," and the ",(0,o.kt)("em",{parentName:"li"},"querier")," (we'll discuss queries later),"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"env"),":  keeps information about the execution environment, e.g., the address of the current contract,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"info"),": keeps information about the message that is currently executed, e.g., the address of the message sender,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"msg"),":  the ",(0,o.kt)("inlineCode",{parentName:"li"},"InstantiateMsg")," that we just defined.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"deps"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"env"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"info")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"msg")," values are provided automatically by the ",(0,o.kt)("inlineCode",{parentName:"p"},"wasmd")," module when executing a\ncontract's entrypoint. Most entry points expect a very similar set of arguments, with slight variations.")),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()")," implementation sets the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"COUNTER")," storage item to ",(0,o.kt)("inlineCode",{parentName:"p"},"InstantiateMsg.initial_value"),". This\nis our first time saving something to storage, which is quite exciting!"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," Reading and writing to storage consumes gas, which costs money.")),(0,o.kt)("p",null,"Finally, in our ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()")," implementation, we add ",(0,o.kt)("strong",{parentName:"p"},"attributes")," to the successful ",(0,o.kt)("inlineCode",{parentName:"p"},"Response"),". This helps with\ndebugging (we'll cover this in the last section of Part 1). Adding attributes to your response acts like a form of\nlogging. Alternatively, we could just return ",(0,o.kt)("inlineCode",{parentName:"p"},"Ok(Response::new())"),", and that would work perfectly fine."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"Important information:")," errors and errors handling"),(0,o.kt)("p",null,(0,o.kt)("p",null,"The return type of our entrypoint is ",(0,o.kt)("inlineCode",{parentName:"p"},"Result<Response<NeutronMsg>, ContractError>"),". In simple terms, this means that\nit can either return a valid ",(0,o.kt)("inlineCode",{parentName:"p"},"Response")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractError"),"."),(0,o.kt)("p",null,"If this was really a ",(0,o.kt)("strong",{parentName:"p"},"minimal")," example, we would not define our own error type, and would simply\nreturn ",(0,o.kt)("inlineCode",{parentName:"p"},'Err(StdError::generic_err("error message"))')," in case of an error. However, in most cases you want to define\ncontract-specific errors, which we will do in the next section."),(0,o.kt)("p",null,"You might not have noticed it, but in our implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate()")," entrypoint we do some minimal error\nhandling!"),(0,o.kt)("p",null,"Storage operations can potentially fail (although they usually succeed). In our implementation, if the ",(0,o.kt)("inlineCode",{parentName:"p"},".save()")," call\nfails for whatever reason, we immediately propagate the error by putting the ",(0,o.kt)("inlineCode",{parentName:"p"},"?")," operator at the end of the ",(0,o.kt)("inlineCode",{parentName:"p"},".save()"),"\ncall. It's also possible to handle errors manually using Rust's ",(0,o.kt)("inlineCode",{parentName:"p"},"match"),"\noperator (\nsee ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#matching-on-different-errors"},"Rust documentation"),")."))),(0,o.kt)("h3",{id:"processing-messages-how-do-i-make-a-contract-do-something"},"Processing messages: how do I make a contract do something?"),(0,o.kt)("admonition",{title:"TL;DR",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Define all possible messages that your contract needs to process, implement handlers for each of those messages, and\nmatch the messages to handlers in the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," entrypoint."),(0,o.kt)("p",{parentName:"admonition"},"See it in context: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/main/minimal_contract/src/contract.rs#L66-L147"},"link"))),(0,o.kt)("h4",{id:"executemsg-defining-the-set-of-possible-actions"},(0,o.kt)("inlineCode",{parentName:"h4"},"ExecuteMsg"),": defining the set of possible actions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n    IncreaseCount { amount: Uint128 },\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," ",(0,o.kt)("inlineCode",{parentName:"p"},'#[serde(rename_all = "snake_case")]'),' is used to achieve "standard" JSON representation of messages. E.g.,\nthe JSON representation of the ',(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," message will look like this: ",(0,o.kt)("inlineCode",{parentName:"p"},'{"increase_count": {"amount": "42"}}'))),(0,o.kt)("p",null,"When you start developing a contract, the first thing that you need to figure out is what actions to you want the\ncontract to perform."),(0,o.kt)("p",null,"In the snippet above, we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," enum that has a single variant: the ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," message, which\na ",(0,o.kt)("inlineCode",{parentName:"p"},"Uint128")," amount field. This means that our contract is going to be able to process only one type of message."),(0,o.kt)("p",null,"Let's say that upon receiving this message, the contract must increase the ",(0,o.kt)("inlineCode",{parentName:"p"},"COUNTER")," storage item value by the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"\nspecified in the message, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," is less than 100. Matching this particular logic to the ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseCount"),"\nmessage type is done in the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," entrypoint."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"A note on project layout:")," usually all messages are defined in a separate file (",(0,o.kt)("inlineCode",{parentName:"p"},"src/msgs.rs"),"), alongside the\n",(0,o.kt)("inlineCode",{parentName:"p"},"src/contract.rs")," file. Here we define everything in one place for the sake of simplicity.")),(0,o.kt)("h4",{id:"execute-entrypoint-defining-handlers-for-messages"},(0,o.kt)("inlineCode",{parentName:"h4"},"execute()")," entrypoint: defining handlers for messages"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub const MAX_INCREASE_AMOUNT: Uint128 = Uint128::new(100u128);\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    /// Keep access to the StdError, just in case.\n    #[error(transparent)]\n    Std(#[from] StdError),\n\n    /// We will return this error if the user tries to increment the counter by\n    /// more than 100. For no particular reason.\n    #[error("Can not increment by more than 100 (got {amount})")]\n    InvalidIncreaseAmount { amount: Uint128 },\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env, // We don\'t use Env in our implementation, hence the underscore\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response<NeutronMsg>, ContractError> {\n    match msg {\n        ExecuteMsg::IncreaseCount { amount } => execute_increase_amount(deps, info, amount),\n    }\n}\n\npub fn execute_increase_amount(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Uint128,\n) -> Result<Response<NeutronMsg>, ContractError> {\n    // Return the InvalidIncreaseAmount error if the user tries to increase\n    // by more than 100. We save this value in a well-named constant\n    // MAX_INCREASE_AMOUNT because we are nice people.\n    if amount.gt(&MAX_INCREASE_AMOUNT) {\n        return Err(ContractError::InvalidIncreaseAmount { amount });\n    }\n\n    // We need to increase the counter. Step 1: load the current value.\n    // This operation consumes gas!\n    let mut counter = COUNTER.load(deps.storage)?;\n\n    // Step 2: add the user value to the value loaded from the storage.\n    counter += amount;\n\n    // Step 3: save the increased amount to the storage.\n    COUNTER.save(deps.storage, &counter)?;\n\n    Ok(Response::default()\n        .add_attribute("action", "execute_add")\n        .add_attribute("amount", amount.to_string())\n        .add_attribute("sender", info.sender))\n}\n')),(0,o.kt)("p",null,"In most contracts, the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," entry point doesn\u2019t contain specific logic itself; it simply delegates tasks to the\nappropriate handlers based on the message type. That\u2019s exactly what we did in the snippet above: we implemented\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"execute_increase_amount()")," handler and directed our contract to use it when an ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," message is received."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," If the incoming message cannot be parsed into any known message type, an error will be returned.")),(0,o.kt)("p",null,"Here are a few important points:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We set the maximum allowed increase amount using the ",(0,o.kt)("inlineCode",{parentName:"li"},"MAX_INCREASE_AMOUNT")," constant, following best practices."),(0,o.kt)("li",{parentName:"ol"},"We defined the ",(0,o.kt)("inlineCode",{parentName:"li"},"ContractError")," type to return custom errors. The ",(0,o.kt)("inlineCode",{parentName:"li"},"InvalidIncreaseAmount")," variant includes\nthe ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," parameter to make the error message more informative."),(0,o.kt)("li",{parentName:"ol"},"If the user tries to increase the counter by more than ",(0,o.kt)("inlineCode",{parentName:"li"},"MAX_INCREASE_AMOUNT"),", we return an error. (First time in this\ntutorial, right? ",(0,o.kt)("strong",{parentName:"li"},"Exciting!"),")"),(0,o.kt)("li",{parentName:"ol"},"If the user input is valid, we load the current counter value from storage, increase it by the specified amount, and\nsave the new value back to storage."),(0,o.kt)("li",{parentName:"ol"},"Similar to the ",(0,o.kt)("inlineCode",{parentName:"li"},"instantiate()")," implementation, we add some attributes to the response to facilitate easier debugging.")),(0,o.kt)("h3",{id:"querying-data-how-do-i-query-data"},"Querying data: how do I... query data?"),(0,o.kt)("admonition",{title:"TL;DR",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Define all possible query messages that your contract needs to process, implement handlers for each of those messages,\nand match the messages to handlers in the ",(0,o.kt)("inlineCode",{parentName:"p"},"query()")," entrypoint."),(0,o.kt)("p",{parentName:"admonition"},"See it in context: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neutron-org/onboarding/blob/main/minimal_contract/src/contract.rs#L66-L147"},"link"))),(0,o.kt)("p",null,"Querying the raw storage data from a smart contract is ",(0,o.kt)("strong",{parentName:"p"},"technically")," possible, but is not very convenient. If you want\nyour contract to provide information about it state, you need to (guess what?) implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"QueryMsg")," and the\n",(0,o.kt)("inlineCode",{parentName:"p"},"query()")," entrypoint. The process is very similar to what we did with the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," entrypoint, the only difference\nbeing that in the ",(0,o.kt)("inlineCode",{parentName:"p"},"query()")," entrypoint you can not modify the state, and that you don't have the ",(0,o.kt)("inlineCode",{parentName:"p"},"MessageInfo")," data in\nit."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// A query message to get the current value of COUNTER. The #[returns(Uint128)]\n    /// derive marco here is required to generate proper JSON schemas for out smart\n    /// contract.\n    #[returns(Uint128)]\n    CurrentValue {},\n}\n\n/// We could simply read the Uint128 value from storage and return it as is,\n/// but in general it\'s better to provide a custom response types for your\n/// queries.\n#[cw_serde]\npub struct CurrentValueResponse {\n    pub current_value: Uint128,\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    // Similar to execute(), we try to parse msg into any of the known variants of QueryMsg.\n    match msg {\n        QueryMsg::CurrentValue {} => query_current_value(deps),\n    }\n}\n\npub fn query_current_value(deps: Deps) -> StdResult<Binary> {\n    let current_value = &COUNTER.load(deps.storage)?;\n    // to_json_binary is a handy helper function from cosmwasm_std that allows you\n    // to convert any properly defined Rust type to StdResult<Binary>.\n    to_json_binary(&CurrentValueResponse {\n        current_value: current_value.clone(),\n    })\n}\n')),(0,o.kt)("p",null,"A few things to note here:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Creating custom response types for your queries is not necessary, but is a good practice, even if you only return a\nsingle number."),(0,o.kt)("li",{parentName:"ul"},"If our contract was a bit more complicated, we could, of course, create a query message with some query parameters,\nand process the query taking the query parameters into account."),(0,o.kt)("li",{parentName:"ul"},"You are not limited to only reading your own storage values in the ",(0,o.kt)("inlineCode",{parentName:"li"},"query()")," entrypoint; you can also query other\ncontracts, and even modules, if necessary. We'll teach you how to do it in ",(0,o.kt)("strong",{parentName:"li"},"Part 3")," of this tutorial.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"A note on project layout:")," usually all custom response types are defined in a separate file (",(0,o.kt)("inlineCode",{parentName:"p"},"src/query.rs"),"),\nalongside the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/contract.rs")," file. Here we define everything in one place for the sake of simplicity.")),(0,o.kt)("h2",{id:"how-to-deploy-and-execute"},"How to deploy and execute?"),(0,o.kt)("h3",{id:"prepare-the-environment"},"Prepare the environment"),(0,o.kt)("p",null,"First of all, you need to install Rust: ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/cargo/getting-started/installation.html"},"https://doc.rust-lang.org/cargo/getting-started/installation.html"),". After\ninstalling Rust, you need to add a wasm target for cargo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"rustup target add wasm32-unknown-unknown\n")),(0,o.kt)("p",null,"Next, install Docker: ",(0,o.kt)("a",{parentName:"p",href:"https://docs.docker.com/engine/install/"},"https://docs.docker.com/engine/install/"),". You need Docker to build reproducible wasm\nbinaries and to run the localnet."),(0,o.kt)("p",null,"Create a directory for this tutorial, e.g.:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"mkdir neutron-cosmwasm-tutorial-part-1 && cd neutron-cosmwasm-tutorial-part-1\n")),(0,o.kt)("p",null,"Next, you need to get a ",(0,o.kt)("inlineCode",{parentName:"p"},"neutrond")," binary. If you don't have Go installed, install Go 1.21 (",(0,o.kt)("a",{parentName:"p",href:"https://go.dev/dl/"},"https://go.dev/dl/"),")."),(0,o.kt)("p",null,"Clone the Neutron repository and install the ",(0,o.kt)("inlineCode",{parentName:"p"},"neutrond")," binary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/neutron-org/neutron && cd neutron && make install && cd ..\n")),(0,o.kt)("p",null,"This will put the ",(0,o.kt)("inlineCode",{parentName:"p"},"neutrond")," binary to your ",(0,o.kt)("inlineCode",{parentName:"p"},"$GOPATH/bin"),". If you don't have ",(0,o.kt)("inlineCode",{parentName:"p"},"$GOPATH/bin")," exported yet, export it now\nto be able to execute the binary conveniently from anywhere on your machine:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"export PATH=$PATH:$GOPATH/bin\n")),(0,o.kt)("p",null,"Finally, clone the onboarding tutorial repo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"git clone git@github.com:neutron-org/onboarding.git\ncd onboarding\n")),(0,o.kt)("h3",{id:"run-the-localnet"},"Run the localnet"),(0,o.kt)("p",null,"First, install the ",(0,o.kt)("inlineCode",{parentName:"p"},"cosmopark")," tool that allows you to run custom Neutron localnet setups (input ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," when prompted to\ninstall the package):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npx @neutron-org/cosmopark --help\n")),(0,o.kt)("p",null,"Next, build the images that are required to run a localnet of Neutron consisting of Neutron itself, Gaia, and IBC\nrelayer and an interchain queries relayer. This might be a bit of overkill for our current purposes, but it's good\nto know how to run a real world setup:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"./dockerfiles/build-all.sh\n")),(0,o.kt)("p",null,"Then, start the local network:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'npx @neutron-org/cosmopark@latest start localnet_config.json\n\ud83d\ude80 Starting\n{"level":30,"time":1719406723924,"pid":85823,"hostname":"Andreis-MBP","chain":"neutron","msg":"Starting ics chain neutron"}\n<...>\n\ud83e\udd73 Done\n{"level":20,"time":1729261511883,"pid":52118,"hostname":"Andreis-MBP","context":"main","msg":"cosmopark started"}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," if you want to shut down the localnet, run ",(0,o.kt)("inlineCode",{parentName:"p"},"npx @neutron-org/cosmopark@latest stop localnet_config.json"),".")),(0,o.kt)("p",null,"Now you have several containers running on your local machine. One of them is ",(0,o.kt)("inlineCode",{parentName:"p"},"main-neutron_ics-1"),", which is the\ncontainer running Neutron."),(0,o.kt)("p",null,"In order to execute any messages, you need to import a key using one of the localnet mnemonics:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond keys add demowallet1 --recover\n> Enter your bip39 mnemonic\n> kiwi valid tiger wish shop time exile client metal view spatial ahead\n\n- address: neutron13nfu3ct5xkr0vlswgk3gl9zazp7zan88edz67j\n  name: demowallet1\n  pubkey: \'{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AqVGLu0hlIfruwPYSddOyDmiy7a2kZ0mJ3Qan8vwzXak"}\'\n  type: local\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," you can find more demo mnemonics in the ",(0,o.kt)("inlineCode",{parentName:"p"},"localnet_config.json")," file.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important note:")," you can also import your account from a Ledger by\nrunning ",(0,o.kt)("inlineCode",{parentName:"p"},"neutrond keys add my_ledger_account --ledger"),". Your private key won't be transferred, obviously; to use\nan account created this way to execute transactions you will always need to specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"--ledger")," flag in addition\nto the flags normally provided to a command.")),(0,o.kt)("p",null,"To make sure that everything works well, query the balance of your account:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q bank balances neutron13nfu3ct5xkr0vlswgk3gl9zazp7zan88edz67j --node tcp://0.0.0.0:26657\nbalances:\n- amount: "999975000"\n  denom: untrn\npagination:\n  next_key: null\n  total: "0"\n\n')),(0,o.kt)("h3",{id:"compile-the-contract-binary"},"Compile the contract binary"),(0,o.kt)("p",null,"Go to the ",(0,o.kt)("inlineCode",{parentName:"p"},"minimal_contract")," project directory in the ",(0,o.kt)("inlineCode",{parentName:"p"},"onboarding")," repository:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cd onboarding/minimal_contract\n")),(0,o.kt)("p",null,"Then build the contract binary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'docker run --rm -v "$(pwd)":/code \\\n  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  --platform linux/amd64 \\\n  cosmwasm/optimizer:0.16.0\ncd ..\n')),(0,o.kt)("p",null,"You will find the compiled binary in ",(0,o.kt)("inlineCode",{parentName:"p"},"minimal_contract/artifacts/minimal_contract.wasm"),"."),(0,o.kt)("h3",{id:"upload-the-contract"},"Upload the contract"),(0,o.kt)("p",null,"First, you need to upload the contract binary (copy the ",(0,o.kt)("inlineCode",{parentName:"p"},"txhash")," value from the last line of the command output!):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"neutrond tx wasm store minimal_contract/artifacts/minimal_contract.wasm \\\n --node tcp://0.0.0.0:26657 --chain-id ntrntest --gas 3000000 \\\n --fees 10000untrn --from demowallet1\n")),(0,o.kt)("p",null,"Let's see what the command arguments stand for here, because ",(0,o.kt)("strong",{parentName:"p"},"it's very important for your general understanding of how\nNeutron works"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"minimal_contract/artifacts/minimal_contract.wasm"),": path to the compiled contract binary."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--node tcp://0.0.0.0:26657"),": address of the Neutron node's RPC endpoint. This particular port is exposed by\nthe ",(0,o.kt)("inlineCode",{parentName:"li"},"main-neutron_ics-1")," container that we started in the previous section; for mainnet RPC providers, please visit\nthe ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosmos/chain-registry/blob/master/neutron/chain.json#L208"},"mainnet chain registry"),"; for\ntestnet RPC providers, please visit\nthe ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosmos/chain-registry/blob/master/testnets/neutrontestnet/chain.json#L151"},"testnet chain registry"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--chain-id ntrntest"),": the chain identifier; any running Cosmos chain has an identifier that you need to provide for\nall ",(0,o.kt)("inlineCode",{parentName:"li"},"tx")," commands. We gave this identifier to our localnet in the ",(0,o.kt)("inlineCode",{parentName:"li"},"localnet_config.json")," file. You can find the\nmainnet ",(0,o.kt)("inlineCode",{parentName:"li"},"chain_id")," ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosmos/chain-registry/blob/master/neutron/chain.json#L7"},"here"),", and the\ntestnet ",(0,o.kt)("inlineCode",{parentName:"li"},"chain_id")," ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosmos/chain-registry/blob/master/testnets/neutrontestnet/chain.json#L7"},"here"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--gas 1500000"),": the gas limit for this transaction; if your gas limit is too low, the transaction will fail. If the\ntransaction failed, you can query the transaction details (shown below) to see what amount of gas was actually\nconsumed by the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--fees 4000untrn"),": the amount that you are ready to pay for executing the transaction; if your fee is too low, the\ntransaction will fail. If the transaction failed, you can query the transaction details (shown below) to see what fee\nwas actually required to execute the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--from demowallet1"),": the account that you are using to sign this transaction.")),(0,o.kt)("p",null,"Next, you need to get the ",(0,o.kt)("inlineCode",{parentName:"p"},"code_id")," of the binary that you just uploaded:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q tx 855C2F0D3E120D986B65EB250BBB3C24ED38F7251E928F03DB96AF8186C00973 --output json \\\n  --node tcp://0.0.0.0:26657 | jq ".events[8]"  \n{\n  "type": "store_code",\n  "attributes": [\n    {\n      "key": "code_checksum",\n      "value": "5aca867b2af7295c7ff224dd62605a8f1601ccee73161ed41e4c43034327f021",\n      "index": true\n    },\n    {\n      "key": "code_id",\n      "value": "20",\n      "index": true\n    }\n  ]\n}\n')),(0,o.kt)("p",null,"You can see in the output above that the ",(0,o.kt)("inlineCode",{parentName:"p"},"code_id")," of our contract binary is ",(0,o.kt)("inlineCode",{parentName:"p"},"19"),". Now that we know it, we can finally\ninstantiate our contract (once again, copy the ",(0,o.kt)("inlineCode",{parentName:"p"},"txhash")," value):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond tx wasm instantiate 20 \'{"initial_value": "42"}\' --label minimal_contract \\\n  --no-admin --node tcp://0.0.0.0:26657 --from demowallet1 --chain-id ntrntest \\\n  --gas 3000000 --fees 10000untrn\n')),(0,o.kt)("p",null,"Lets have a look at the transaction arguments and flags once again:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"20"),": the ",(0,o.kt)("inlineCode",{parentName:"li"},"code_id")," that we got after uploading our compiled binary. As we mentioned previously, you can instantiate\nmultiple identical contracts from one ",(0,o.kt)("inlineCode",{parentName:"li"},"code_id"),"!"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'\'{"initial_value": "42"}\''),": that's our ",(0,o.kt)("inlineCode",{parentName:"li"},"InstantiateMsg")," that we defined in our contract. If we provided a JSON that\ncould not be parsed into ",(0,o.kt)("inlineCode",{parentName:"li"},"InstantiateMsg"),", we would receive an error."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--label minimal_contract"),": every CosmWasm contract needs to have a user-defined label."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"--no-admin")," means that we created our contract without an admin address. The admin address can ",(0,o.kt)("em",{parentName:"li"},"migrate")," a contract.")),(0,o.kt)("p",null,"Now, we need to query the transaction details to get the address of the instantiated contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q tx B45E9D20A5744A81C2C3B0E75D0E740E56E0E0FD20206DDFC77F6FCFE11333B8 --output json --node tcp://0.0.0.0:26657 | jq ".events[8]"\n{\n  "type": "instantiate",\n  "attributes": [\n    {\n      "key": "_contract_address",\n      "value": "neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj",\n      "index": true\n    },\n    {\n      "key": "code_id",\n      "value": "20",\n      "index": true\n    }\n  ]\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Congratulations!")," The contract is now instantiated, and is ready to process our messages."),(0,o.kt)("admonition",{title:"Contract addresses",type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"The address of your contract might be different from what you see in this tutorial. Make sure that you are replacing\nthe addresses from the commands below with the address of ",(0,o.kt)("strong",{parentName:"p"},"your")," contract!")),(0,o.kt)("h3",{id:"interact-with-the-contract"},"Interact with the contract"),(0,o.kt)("p",null,"Now that the contract is instantiated and we know its address, let's first see whether what that current value of the\ncounter is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q wasm contract-state smart neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj \\\n  \'{"current_value": {}}\' --output json --node tcp://0.0.0.0:26657\n{"data":{"current_value":"42"}}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Important note:")," we have the number as a string here because that's how ",(0,o.kt)("inlineCode",{parentName:"p"},"Uint128")," is represented (it's a potentially\nvery big number). When using ",(0,o.kt)("inlineCode",{parentName:"p"},"Uint128")," value in JSON, you need to provide them as strings.")),(0,o.kt)("p",null,"The current value is ",(0,o.kt)("inlineCode",{parentName:"p"},"42"),", which means that our instantiate message did its job. Let's now increase the value by\n",(0,o.kt)("inlineCode",{parentName:"p"},"1")," by sending an ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseCount")," message to it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond tx wasm execute neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj \\\n  \'{"increase_count": {"amount": "1"}}\' --node tcp://0.0.0.0:26657 --from demowallet1 \\\n  --chain-id ntrntest --gas 1500000 --fees 4000untrn\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj"),": the address of our instantiated contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'\'{"increase_count": {"amount": "1"}}\''),": the JSON representation of the ",(0,o.kt)("inlineCode",{parentName:"li"},"ExecuteMsg::IncreaseCount")," message that we\ndefined in our contract.")),(0,o.kt)("p",null,"If we query the contract once again, we'll see that the current value was increased by 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'neutrond q wasm contract-state smart neutron1nyuryl5u5z04dx4zsqgvsuw7fe8gl2f77yufynauuhklnnmnjncqcls0tj \\\n  \'{"current_value": {}}\' --output json --node tcp://0.0.0.0:26657\n{"data":{"current_value":"43"}}\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this first part of the tutorial, you learned how to create a simple, yet functional smart contract using CosmWasm,\nand to deploy and interact with it locally. In the second part of the tutorial, you will learn how to interact with\nNeutron modules and other smart contracts."))}m.isMDXComponent=!0}}]);